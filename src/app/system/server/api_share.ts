//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import LayoutComponentBase from 'src/app/share/layoutBase/LayoutComponentBase';
import { Injector } from '@angular/core';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { APIBase } from './APIBase';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ISysActionClient {
    sysActionIns(action: SysAction): Observable<StatusMessageOfSysAction>;
    sysActionUpd(action: SysAction): Observable<StatusMessageOfObject>;
    sysActionDel(action: SysAction): Observable<StatusMessageOfObject>;
    sysActionGetByCode(code?: string | undefined): Observable<SysAction>;
    sysActionGetByCodeByPermision(actionCode?: string | undefined): Observable<SysAction[]>;
    sysDropDownActionIns(dropdownAction: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction>;
    sysDropdownActionUpd(action: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction>;
    sysDropdownActionDel(action: SysDropDownAction): Observable<StatusMessageOfObject>;
    sysDropActionGetListSysActionByCode(dropdownAction: SysDropDownAction): Observable<SysAction[]>;
    sysDropdownActionGet(actionCode: SysDropDownAction): Observable<SysDropDownAction>;
    getListActionByGroupCode(groupAction: SysGroupAction): Observable<StatusMessageOfListOfSysAction>;
}

@Injectable()
export class SysActionClient extends APIBase implements ISysActionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    sysActionIns(action: SysAction): Observable<StatusMessageOfSysAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysAction>;
        }));
    }

    protected processSysActionIns(response: HttpResponseBase): Observable<StatusMessageOfSysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionUpd(action: SysAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionUpd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionUpd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionUpd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysActionUpd(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionDel(action: SysAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionDel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysActionDel(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionGetByCode(code?: string | undefined): Observable<SysAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionGetByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionGetByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction>;
        }));
    }

    protected processSysActionGetByCode(response: HttpResponseBase): Observable<SysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionGetByCodeByPermision(actionCode?: string | undefined): Observable<SysAction[]> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionGetByCode2?";
        if (actionCode === null)
            throw new Error("The parameter 'actionCode' cannot be null.");
        else if (actionCode !== undefined)
            url_ += "actionCode=" + encodeURIComponent("" + actionCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionGetByCodeByPermision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionGetByCodeByPermision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction[]>;
        }));
    }

    protected processSysActionGetByCodeByPermision(response: HttpResponseBase): Observable<SysAction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropDownActionIns(dropdownAction: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropDownActionIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dropdownAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropDownActionIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropDownActionIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysDropDownAction>;
        }));
    }

    protected processSysDropDownActionIns(response: HttpResponseBase): Observable<StatusMessageOfSysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionUpd(action: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropdownActionUpd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionUpd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionUpd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysDropDownAction>;
        }));
    }

    protected processSysDropdownActionUpd(response: HttpResponseBase): Observable<StatusMessageOfSysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionDel(action: SysDropDownAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropdownActionDel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysDropdownActionDel(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropActionGetListSysActionByCode(dropdownAction: SysDropDownAction): Observable<SysAction[]> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropActionGetListSysActionByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dropdownAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropActionGetListSysActionByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropActionGetListSysActionByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction[]>;
        }));
    }

    protected processSysDropActionGetListSysActionByCode(response: HttpResponseBase): Observable<SysAction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionGet(actionCode: SysDropDownAction): Observable<SysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropActionGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionCode);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysDropDownAction>;
        }));
    }

    protected processSysDropdownActionGet(response: HttpResponseBase): Observable<SysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListActionByGroupCode(groupAction: SysGroupAction): Observable<StatusMessageOfListOfSysAction> {
        let url_ = this.baseUrl + "/api/sysAction/GetListActionByGroupCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListActionByGroupCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListActionByGroupCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysAction>;
        }));
    }

    protected processGetListActionByGroupCode(response: HttpResponseBase): Observable<StatusMessageOfListOfSysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysGenRowTablesClient {
    genRowTableInsert(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableUpdate(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableDelete(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableSearch(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfListOfSysGenRowTable>;
}

@Injectable()
export class SysGenRowTablesClient extends APIBase implements ISysGenRowTablesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    genRowTableInsert(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableInsert(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableUpdate(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableDelete(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableDelete(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableSearch(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfListOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysMenusClient {
    sysMenuSearch(model: SysMenu): Observable<StatusMessageOfListOfSysMenu>;
    sysMenuInsert(model: SysMenu): Observable<StatusMessageOfSysMenu>;
    sysMenuUpdate(model: SysMenu): Observable<StatusMessageOfSysMenu>;
    sysMenuDelete(model: SysMenu): Observable<StatusMessageOfObject>;
}

@Injectable()
export class SysMenusClient extends APIBase implements ISysMenusClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    sysMenuSearch(model: SysMenu): Observable<StatusMessageOfListOfSysMenu> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysMenu>;
        }));
    }

    protected processSysMenuSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysMenuInsert(model: SysMenu): Observable<StatusMessageOfSysMenu> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysMenu>;
        }));
    }

    protected processSysMenuInsert(response: HttpResponseBase): Observable<StatusMessageOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysMenuUpdate(model: SysMenu): Observable<StatusMessageOfSysMenu> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysMenu>;
        }));
    }

    protected processSysMenuUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysMenuDelete(model: SysMenu): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysMenuDelete(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysVoucherFormClient {
    voucherFormColumnInsert(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnUpdate(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnDelete(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnSearch(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfListOfSysVoucherFormColumn>;
    voucherFormGroupInsert(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupUpdate(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupDelete(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupSearch(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfListOfSysVoucherFormGroup>;
}

@Injectable()
export class SysVoucherFormClient extends APIBase implements ISysVoucherFormClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    voucherFormColumnInsert(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnInsert(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnUpdate(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnDelete(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnDelete(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnSearch(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfListOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupInsert(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupInsert(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupUpdate(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupDelete(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupDelete(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupSearch(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfListOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICurrentJobPositionsClient {
    getCurrentJobPositions(): Observable<CurrentJobPosition[]>;
    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition>;
    getCurrentJobPosition(id: string): Observable<CurrentJobPosition>;
    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse>;
    deleteCurrentJobPosition(id: string): Observable<FileResponse>;
}

@Injectable()
export class CurrentJobPositionsClient extends APIBase implements ICurrentJobPositionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getCurrentJobPositions(): Observable<CurrentJobPosition[]> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition[]>;
        }));
    }

    protected processGetCurrentJobPositions(response: HttpResponseBase): Observable<CurrentJobPosition[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrentJobPosition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processPostCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrentJobPosition(id: string): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processGetCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCurrentJobPosition(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISalaryAndBenefitsClient {
    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]>;
    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits>;
    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits>;
    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse>;
    deleteSalaryAndBenefits(id: string): Observable<FileResponse>;
}

@Injectable()
export class SalaryAndBenefitsClient extends APIBase implements ISalaryAndBenefitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefitsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefitsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits[]>;
        }));
    }

    protected processGetSalaryAndBenefitsAll(response: HttpResponseBase): Observable<SalaryAndBenefits[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalaryAndBenefits.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processPostSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processGetSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSalaryAndBenefits(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWorkHistoriesClient {
    getWorkHistories(): Observable<WorkHistory[]>;
    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory>;
    getWorkHistory(id: string): Observable<WorkHistory>;
    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse>;
    deleteWorkHistory(id: string): Observable<FileResponse>;
}

@Injectable()
export class WorkHistoriesClient extends APIBase implements IWorkHistoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getWorkHistories(): Observable<WorkHistory[]> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory[]>;
        }));
    }

    protected processGetWorkHistories(response: HttpResponseBase): Observable<WorkHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processPostWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWorkHistory(id: string): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processGetWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWorkHistory(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMovieCommentClient {
    insert(model: MovieCommentModel): Observable<StatusMessageOfMovieCommentModel>;
    delete(model: MovieCommentModel): Observable<StatusMessageOfMovieCommentModel>;
    update(model: MovieCommentModel): Observable<StatusMessageOfMovieCommentModel>;
    search(model: MovieCommentModel): Observable<StatusMessageOfListOfMovieCommentModel>;
    searchByDate(model: MovieCommentModel): Observable<StatusMessageOfListOfMovieCommentModel>;
}

@Injectable()
export class MovieCommentClient extends APIBase implements IMovieCommentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    insert(model: MovieCommentModel): Observable<StatusMessageOfMovieCommentModel> {
        let url_ = this.baseUrl + "/api/MovieComment/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieCommentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieCommentModel>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<StatusMessageOfMovieCommentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieCommentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(model: MovieCommentModel): Observable<StatusMessageOfMovieCommentModel> {
        let url_ = this.baseUrl + "/api/MovieComment/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieCommentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieCommentModel>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<StatusMessageOfMovieCommentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieCommentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(model: MovieCommentModel): Observable<StatusMessageOfMovieCommentModel> {
        let url_ = this.baseUrl + "/api/MovieComment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieCommentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieCommentModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StatusMessageOfMovieCommentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieCommentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(model: MovieCommentModel): Observable<StatusMessageOfListOfMovieCommentModel> {
        let url_ = this.baseUrl + "/api/MovieComment/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieCommentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieCommentModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieCommentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieCommentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchByDate(model: MovieCommentModel): Observable<StatusMessageOfListOfMovieCommentModel> {
        let url_ = this.baseUrl + "/api/MovieComment/SearchByDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchByDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieCommentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieCommentModel>;
        }));
    }

    protected processSearchByDate(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieCommentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieCommentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMovieClient {
    insert(model: MovieModel): Observable<StatusMessageOfMovieModel>;
    update(model: MovieModel): Observable<StatusMessageOfMovieModel>;
    delete(model: MovieModel): Observable<StatusMessageOfMovieModel>;
    get(model: MovieModel): Observable<StatusMessageOfMovieParamModel>;
    search(model: MovieModel): Observable<StatusMessageOfListOfMovieModel>;
    searchRangePage(model: MovieModel): Observable<StatusMessageOfListOfMovieModel>;
}

@Injectable()
export class MovieClient extends APIBase implements IMovieClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    insert(model: MovieModel): Observable<StatusMessageOfMovieModel> {
        let url_ = this.baseUrl + "/api/Movie/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieModel>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<StatusMessageOfMovieModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(model: MovieModel): Observable<StatusMessageOfMovieModel> {
        let url_ = this.baseUrl + "/api/Movie/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StatusMessageOfMovieModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(model: MovieModel): Observable<StatusMessageOfMovieModel> {
        let url_ = this.baseUrl + "/api/Movie/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieModel>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<StatusMessageOfMovieModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(model: MovieModel): Observable<StatusMessageOfMovieParamModel> {
        let url_ = this.baseUrl + "/api/Movie/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieParamModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieParamModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StatusMessageOfMovieParamModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieParamModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(model: MovieModel): Observable<StatusMessageOfListOfMovieModel> {
        let url_ = this.baseUrl + "/api/Movie/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchRangePage(model: MovieModel): Observable<StatusMessageOfListOfMovieModel> {
        let url_ = this.baseUrl + "/api/Movie/SearchRangePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchRangePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRangePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieModel>;
        }));
    }

    protected processSearchRangePage(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMovieFavoritesClient {
    insert(model: MovieFavoritesModel): Observable<StatusMessageOfMovieFavoritesModel>;
    update(model: MovieFavoritesModel): Observable<StatusMessageOfMovieFavoritesModel>;
    delete(model: MovieFavoritesModel): Observable<StatusMessageOfMovieFavoritesModel>;
    search(model: MovieFavoritesModel): Observable<StatusMessageOfListOfMovieFavoritesModel>;
}

@Injectable()
export class MovieFavoritesClient extends APIBase implements IMovieFavoritesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    insert(model: MovieFavoritesModel): Observable<StatusMessageOfMovieFavoritesModel> {
        let url_ = this.baseUrl + "/api/MovieFavorites/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieFavoritesModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieFavoritesModel>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<StatusMessageOfMovieFavoritesModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieFavoritesModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(model: MovieFavoritesModel): Observable<StatusMessageOfMovieFavoritesModel> {
        let url_ = this.baseUrl + "/api/MovieFavorites/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieFavoritesModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieFavoritesModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StatusMessageOfMovieFavoritesModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieFavoritesModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(model: MovieFavoritesModel): Observable<StatusMessageOfMovieFavoritesModel> {
        let url_ = this.baseUrl + "/api/MovieFavorites/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieFavoritesModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieFavoritesModel>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<StatusMessageOfMovieFavoritesModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieFavoritesModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(model: MovieFavoritesModel): Observable<StatusMessageOfListOfMovieFavoritesModel> {
        let url_ = this.baseUrl + "/api/MovieFavorites/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieFavoritesModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieFavoritesModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieFavoritesModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieFavoritesModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMovieGenresClient {
    insert(model: MovieGenresModel): Observable<StatusMessageOfMovieGenresModel>;
    update(model: MovieGenresModel): Observable<StatusMessageOfMovieGenresModel>;
    delete(model: MovieGenresModel): Observable<StatusMessageOfMovieGenresModel>;
    search(model: MovieGenresModel): Observable<StatusMessageOfListOfMovieGenresModel>;
}

@Injectable()
export class MovieGenresClient extends APIBase implements IMovieGenresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    insert(model: MovieGenresModel): Observable<StatusMessageOfMovieGenresModel> {
        let url_ = this.baseUrl + "/api/MovieGenres/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieGenresModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieGenresModel>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<StatusMessageOfMovieGenresModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieGenresModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(model: MovieGenresModel): Observable<StatusMessageOfMovieGenresModel> {
        let url_ = this.baseUrl + "/api/MovieGenres/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieGenresModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieGenresModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StatusMessageOfMovieGenresModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieGenresModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(model: MovieGenresModel): Observable<StatusMessageOfMovieGenresModel> {
        let url_ = this.baseUrl + "/api/MovieGenres/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieGenresModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieGenresModel>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<StatusMessageOfMovieGenresModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieGenresModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(model: MovieGenresModel): Observable<StatusMessageOfListOfMovieGenresModel> {
        let url_ = this.baseUrl + "/api/MovieGenres/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieGenresModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieGenresModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieGenresModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieGenresModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMovieReviewClient {
    insert(model: MovieReivewModel): Observable<StatusMessageOfMovieReivewModel>;
    update(model: MovieReivewModel): Observable<StatusMessageOfMovieReivewModel>;
    delete(model: MovieReivewModel): Observable<StatusMessageOfMovieReivewModel>;
    search(model: MovieReivewModel): Observable<StatusMessageOfListOfMovieReivewModel>;
    searchRangePage(model: MovieReivewModel): Observable<StatusMessageOfListOfMovieReivewModel>;
}

@Injectable()
export class MovieReviewClient extends APIBase implements IMovieReviewClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    insert(model: MovieReivewModel): Observable<StatusMessageOfMovieReivewModel> {
        let url_ = this.baseUrl + "/api/MovieReview/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieReivewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieReivewModel>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<StatusMessageOfMovieReivewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieReivewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(model: MovieReivewModel): Observable<StatusMessageOfMovieReivewModel> {
        let url_ = this.baseUrl + "/api/MovieReview/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieReivewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieReivewModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<StatusMessageOfMovieReivewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieReivewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(model: MovieReivewModel): Observable<StatusMessageOfMovieReivewModel> {
        let url_ = this.baseUrl + "/api/MovieReview/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieReivewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieReivewModel>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<StatusMessageOfMovieReivewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieReivewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(model: MovieReivewModel): Observable<StatusMessageOfListOfMovieReivewModel> {
        let url_ = this.baseUrl + "/api/MovieReview/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieReivewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieReivewModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieReivewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieReivewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchRangePage(model: MovieReivewModel): Observable<StatusMessageOfListOfMovieReivewModel> {
        let url_ = this.baseUrl + "/api/MovieReview/SearchRangePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchRangePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRangePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieReivewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieReivewModel>;
        }));
    }

    protected processSearchRangePage(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieReivewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieReivewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMovieWatchHistoryClient {
    insert(model: MovieWatchHistoryModel): Observable<StatusMessageOfMovieWatchHistoryModel>;
    delete(model: MovieWatchHistoryModel): Observable<StatusMessageOfMovieWatchHistoryModel>;
    search(model: MovieWatchHistoryModel): Observable<StatusMessageOfListOfMovieWatchHistoryModel>;
    searchRangePage(model: MovieWatchHistoryModel): Observable<StatusMessageOfListOfMovieWatchHistoryModel>;
}

@Injectable()
export class MovieWatchHistoryClient extends APIBase implements IMovieWatchHistoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    insert(model: MovieWatchHistoryModel): Observable<StatusMessageOfMovieWatchHistoryModel> {
        let url_ = this.baseUrl + "/api/MovieWatchHistory/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieWatchHistoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieWatchHistoryModel>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<StatusMessageOfMovieWatchHistoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieWatchHistoryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(model: MovieWatchHistoryModel): Observable<StatusMessageOfMovieWatchHistoryModel> {
        let url_ = this.baseUrl + "/api/MovieWatchHistory/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMovieWatchHistoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMovieWatchHistoryModel>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<StatusMessageOfMovieWatchHistoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMovieWatchHistoryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(model: MovieWatchHistoryModel): Observable<StatusMessageOfListOfMovieWatchHistoryModel> {
        let url_ = this.baseUrl + "/api/MovieWatchHistory/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieWatchHistoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieWatchHistoryModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieWatchHistoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieWatchHistoryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchRangePage(model: MovieWatchHistoryModel): Observable<StatusMessageOfListOfMovieWatchHistoryModel> {
        let url_ = this.baseUrl + "/api/MovieWatchHistory/SearchRangePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchRangePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRangePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfMovieWatchHistoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfMovieWatchHistoryModel>;
        }));
    }

    protected processSearchRangePage(response: HttpResponseBase): Observable<StatusMessageOfListOfMovieWatchHistoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfMovieWatchHistoryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAccountsClient {
    checkTheExpirationDateOfToken(): Observable<boolean>;
    login(account: AccountClientLoginParamsModel): Observable<StatusMessageOfObject>;
    accountIns(profile: AccountClientProfileModel): Observable<StatusMessageOfObject>;
    updateAccount(account: Account): Observable<StatusMessageOfObject>;
    deleteAccount(id: string): Observable<StatusMessageOfObject>;
    accountUpdate(model: AccountClientProfileModel): Observable<StatusMessageOfAccountClientProfileModel>;
    accountSearch(model: Account): Observable<StatusMessageOfAccountClientProfileModel>;
    accountGetALL(model: Account): Observable<StatusMessageOfListOfUserInfoGetListModel>;
    getListUserRegister(model: Account): Observable<StatusMessageOfListOfUserInfoGetListModel>;
    accountDelete(model: Account): Observable<StatusMessageOfAccount>;
    accountChangeStatusLock(model: Account): Observable<StatusMessageOfObject>;
    accountChangeStatusApproval(model: Account): Observable<StatusMessageOfObject>;
    accountChangePassword(model: Account): Observable<StatusMessageOfObject>;
}

@Injectable()
export class AccountsClient extends APIBase implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    checkTheExpirationDateOfToken(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Accounts/CheckTheExpirationDateOfToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckTheExpirationDateOfToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTheExpirationDateOfToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckTheExpirationDateOfToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(account: AccountClientLoginParamsModel): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountIns(profile: AccountClientProfileModel): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/AccountIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processAccountIns(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAccount(account: Account): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/UpdateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAccount(id: string): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountUpdate(model: AccountClientProfileModel): Observable<StatusMessageOfAccountClientProfileModel> {
        let url_ = this.baseUrl + "/api/Accounts/AccountUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfAccountClientProfileModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfAccountClientProfileModel>;
        }));
    }

    protected processAccountUpdate(response: HttpResponseBase): Observable<StatusMessageOfAccountClientProfileModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfAccountClientProfileModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountSearch(model: Account): Observable<StatusMessageOfAccountClientProfileModel> {
        let url_ = this.baseUrl + "/api/Accounts/AccountSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfAccountClientProfileModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfAccountClientProfileModel>;
        }));
    }

    protected processAccountSearch(response: HttpResponseBase): Observable<StatusMessageOfAccountClientProfileModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfAccountClientProfileModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountGetALL(model: Account): Observable<StatusMessageOfListOfUserInfoGetListModel> {
        let url_ = this.baseUrl + "/api/Accounts/AccountGetALL";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountGetALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountGetALL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfUserInfoGetListModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfUserInfoGetListModel>;
        }));
    }

    protected processAccountGetALL(response: HttpResponseBase): Observable<StatusMessageOfListOfUserInfoGetListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfUserInfoGetListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListUserRegister(model: Account): Observable<StatusMessageOfListOfUserInfoGetListModel> {
        let url_ = this.baseUrl + "/api/Accounts/GetListUserRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListUserRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUserRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfUserInfoGetListModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfUserInfoGetListModel>;
        }));
    }

    protected processGetListUserRegister(response: HttpResponseBase): Observable<StatusMessageOfListOfUserInfoGetListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfUserInfoGetListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountDelete(model: Account): Observable<StatusMessageOfAccount> {
        let url_ = this.baseUrl + "/api/Accounts/AccountDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfAccount>;
        }));
    }

    protected processAccountDelete(response: HttpResponseBase): Observable<StatusMessageOfAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountChangeStatusLock(model: Account): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/AccountChangeStatusLock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountChangeStatusLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountChangeStatusLock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processAccountChangeStatusLock(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountChangeStatusApproval(model: Account): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/AccountChangeStatusApproval";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountChangeStatusApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountChangeStatusApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processAccountChangeStatusApproval(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountChangePassword(model: Account): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/AccountChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processAccountChangePassword(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICategoryCommonClient {
    categoryCommonSearch(model: CategoryCommonModel): Observable<StatusMessageOfListOfCategoryCommonModel>;
    categoryCommonInsert(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel>;
    categoryCommonUpdate(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel>;
    categoryCommonDelete(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel>;
    nationalLanguageInsert(model: National): Observable<StatusMessageOfNational>;
    nationalLanguageUpdate(model: National): Observable<StatusMessageOfNational>;
    nationalLanguageDelete(model: National): Observable<StatusMessageOfNational>;
    nationalLanguageSearch(model: National): Observable<StatusMessageOfListOfNational>;
    sysPermissionInsert(model: SysPermission): Observable<StatusMessageOfSysPermission>;
    sysPermissionUpdate(model: SysPermission): Observable<StatusMessageOfSysPermission>;
    sysPermissionDelete(model: SysPermission): Observable<StatusMessageOfSysPermission>;
    sysPermissionSearch(model: SysPermission): Observable<StatusMessageOfListOfSysPermission>;
    sysStatusInsert(model: SysStatus): Observable<StatusMessageOfSysStatus>;
    sysStatusUpdate(model: SysStatus): Observable<StatusMessageOfSysStatus>;
    sysStatusDelete(model: SysStatus): Observable<StatusMessageOfSysStatus>;
    sysStatusSearch(model: SysStatus): Observable<StatusMessageOfListOfSysStatus>;
    sysTypeAccountInsert(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount>;
    sysTypeAccountUpdate(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount>;
    sysTypeAccountDelete(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount>;
    sysTypeAccountSearch(model: SysTypeAccount): Observable<StatusMessageOfListOfSysTypeAccount>;
    testDynamicData(model: any): Observable<FileResponse>;
}

@Injectable()
export class CategoryCommonClient extends APIBase implements ICategoryCommonClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    categoryCommonSearch(model: CategoryCommonModel): Observable<StatusMessageOfListOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    categoryCommonInsert(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonInsert(response: HttpResponseBase): Observable<StatusMessageOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    categoryCommonUpdate(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonUpdate(response: HttpResponseBase): Observable<StatusMessageOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    categoryCommonDelete(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonDelete(response: HttpResponseBase): Observable<StatusMessageOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageInsert(model: National): Observable<StatusMessageOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfNational>;
        }));
    }

    protected processNationalLanguageInsert(response: HttpResponseBase): Observable<StatusMessageOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageUpdate(model: National): Observable<StatusMessageOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfNational>;
        }));
    }

    protected processNationalLanguageUpdate(response: HttpResponseBase): Observable<StatusMessageOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageDelete(model: National): Observable<StatusMessageOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfNational>;
        }));
    }

    protected processNationalLanguageDelete(response: HttpResponseBase): Observable<StatusMessageOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageSearch(model: National): Observable<StatusMessageOfListOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfNational>;
        }));
    }

    protected processNationalLanguageSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionInsert(model: SysPermission): Observable<StatusMessageOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysPermission>;
        }));
    }

    protected processSysPermissionInsert(response: HttpResponseBase): Observable<StatusMessageOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionUpdate(model: SysPermission): Observable<StatusMessageOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysPermission>;
        }));
    }

    protected processSysPermissionUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionDelete(model: SysPermission): Observable<StatusMessageOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysPermission>;
        }));
    }

    protected processSysPermissionDelete(response: HttpResponseBase): Observable<StatusMessageOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionSearch(model: SysPermission): Observable<StatusMessageOfListOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysPermission>;
        }));
    }

    protected processSysPermissionSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusInsert(model: SysStatus): Observable<StatusMessageOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysStatus>;
        }));
    }

    protected processSysStatusInsert(response: HttpResponseBase): Observable<StatusMessageOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusUpdate(model: SysStatus): Observable<StatusMessageOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysStatus>;
        }));
    }

    protected processSysStatusUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusDelete(model: SysStatus): Observable<StatusMessageOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysStatus>;
        }));
    }

    protected processSysStatusDelete(response: HttpResponseBase): Observable<StatusMessageOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusSearch(model: SysStatus): Observable<StatusMessageOfListOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysStatus>;
        }));
    }

    protected processSysStatusSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountInsert(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountInsert(response: HttpResponseBase): Observable<StatusMessageOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountUpdate(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountDelete(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountDelete(response: HttpResponseBase): Observable<StatusMessageOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountSearch(model: SysTypeAccount): Observable<StatusMessageOfListOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    testDynamicData(model: any): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CategoryCommon/TestDynamicData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestDynamicData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestDynamicData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processTestDynamicData(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMenuPermissionsClient {
    getListMenu(): Observable<SysMenu[]>;
    getListMenuV2(): Observable<SysMenu[]>;
    listMenuTreeView(): Observable<Sys_Menu_Tree_View_MODEL[]>;
    listMenuById(p: Sys_Menu_Tree_View_MODEL): Observable<Sys_Menu_Tree_View_MODEL[]>;
    getAllListMenu(): Observable<SysMenu>;
    getMenuPermissions(account?: string | undefined): Observable<StatusMessageOfListOfSysMenu>;
    roleMenuSearch(model: MenuPermissionInsModel): Observable<StatusMessageOfMenuPermissionInsModel>;
    roleMenuInsert(model: MenuPermissionInsModel): Observable<StatusMessageOfMenuPermissionInsModel>;
    roleMenuUpdate(model: MenuPermissionInsModel): Observable<StatusMessageOfMenuPermissionInsModel>;
    roleMenuOfUserLogin(): Observable<StatusMessageOfListOfString>;
    roleMenuPermissionByUserNotYet(model: Account): Observable<StatusMessageOfListOfSysMenu>;
}

@Injectable()
export class MenuPermissionsClient extends APIBase implements IMenuPermissionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getListMenu(): Observable<SysMenu[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu[]>;
        }));
    }

    protected processGetListMenu(response: HttpResponseBase): Observable<SysMenu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysMenu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListMenuV2(): Observable<SysMenu[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/sys_menu_get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListMenuV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMenuV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu[]>;
        }));
    }

    protected processGetListMenuV2(response: HttpResponseBase): Observable<SysMenu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysMenu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listMenuTreeView(): Observable<Sys_Menu_Tree_View_MODEL[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_tree_view";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListMenuTreeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMenuTreeView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
        }));
    }

    protected processListMenuTreeView(response: HttpResponseBase): Observable<Sys_Menu_Tree_View_MODEL[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listMenuById(p: Sys_Menu_Tree_View_MODEL): Observable<Sys_Menu_Tree_View_MODEL[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_by_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(p);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListMenuById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMenuById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
        }));
    }

    protected processListMenuById(response: HttpResponseBase): Observable<Sys_Menu_Tree_View_MODEL[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllListMenu(): Observable<SysMenu> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_get_all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllListMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllListMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu>;
        }));
    }

    protected processGetAllListMenu(response: HttpResponseBase): Observable<SysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMenuPermissions(account?: string | undefined): Observable<StatusMessageOfListOfSysMenu> {
        let url_ = this.baseUrl + "/api/MenuPermissions/GetMenuPermissions?";
        if (account === null)
            throw new Error("The parameter 'account' cannot be null.");
        else if (account !== undefined)
            url_ += "account=" + encodeURIComponent("" + account) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMenuPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysMenu>;
        }));
    }

    protected processGetMenuPermissions(response: HttpResponseBase): Observable<StatusMessageOfListOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    roleMenuSearch(model: MenuPermissionInsModel): Observable<StatusMessageOfMenuPermissionInsModel> {
        let url_ = this.baseUrl + "/api/MenuPermissions/RoleMenuSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRoleMenuSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoleMenuSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMenuPermissionInsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMenuPermissionInsModel>;
        }));
    }

    protected processRoleMenuSearch(response: HttpResponseBase): Observable<StatusMessageOfMenuPermissionInsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMenuPermissionInsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    roleMenuInsert(model: MenuPermissionInsModel): Observable<StatusMessageOfMenuPermissionInsModel> {
        let url_ = this.baseUrl + "/api/MenuPermissions/RoleMenuInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRoleMenuInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoleMenuInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMenuPermissionInsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMenuPermissionInsModel>;
        }));
    }

    protected processRoleMenuInsert(response: HttpResponseBase): Observable<StatusMessageOfMenuPermissionInsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMenuPermissionInsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    roleMenuUpdate(model: MenuPermissionInsModel): Observable<StatusMessageOfMenuPermissionInsModel> {
        let url_ = this.baseUrl + "/api/MenuPermissions/RoleMenuUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRoleMenuUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoleMenuUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfMenuPermissionInsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfMenuPermissionInsModel>;
        }));
    }

    protected processRoleMenuUpdate(response: HttpResponseBase): Observable<StatusMessageOfMenuPermissionInsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfMenuPermissionInsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    roleMenuOfUserLogin(): Observable<StatusMessageOfListOfString> {
        let url_ = this.baseUrl + "/api/MenuPermissions/RoleMenuOfUserLogin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRoleMenuOfUserLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoleMenuOfUserLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfString>;
        }));
    }

    protected processRoleMenuOfUserLogin(response: HttpResponseBase): Observable<StatusMessageOfListOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    roleMenuPermissionByUserNotYet(model: Account): Observable<StatusMessageOfListOfSysMenu> {
        let url_ = this.baseUrl + "/api/MenuPermissions/RoleMenuPermissionByUserNotYet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRoleMenuPermissionByUserNotYet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoleMenuPermissionByUserNotYet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysMenu>;
        }));
    }

    protected processRoleMenuPermissionByUserNotYet(response: HttpResponseBase): Observable<StatusMessageOfListOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserInfoesClient {
    userIns(userInfo: UserInfo): Observable<StatusMessageOfObject>;
    updUser(userInfo: UserInfo): Observable<StatusMessageOfObject>;
    getMyUser(): Observable<UserInfo>;
    getLstUser(): Observable<UserInfo[]>;
    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser>;
    deleteUserInfo(id: string): Observable<FileResponse>;
}

@Injectable()
export class UserInfoesClient extends APIBase implements IUserInfoesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    userIns(userInfo: UserInfo): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/UserInfoes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUserIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUserIns(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updUser(userInfo: UserInfo): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/UserInfoes/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUpdUser(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyUser(): Observable<UserInfo> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMyUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo>;
        }));
    }

    protected processGetMyUser(response: HttpResponseBase): Observable<UserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLstUser(): Observable<UserInfo[]> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLstUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLstUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo[]>;
        }));
    }

    protected processGetLstUser(response: HttpResponseBase): Observable<UserInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUserInformation?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInformationClientGetUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInformationClientGetUser>;
        }));
    }

    protected processGetUserInformation(response: HttpResponseBase): Observable<UserInformationClientGetUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInformationClientGetUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUserInfo(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserInfoes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteUserInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICommonContronllerClient {
    listCompany(): Observable<Company[]>;
    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]>;
    getPermissionByCompany(): Observable<SysPermission[]>;
    excuteQueryString(model: QueryCommonModel): Observable<any[]>;
    excuteQueryStringV2(model: QueryCommonModel): Observable<StatusMessageOfString>;
    uploadFileVersion11(table_name?: string | null | undefined, col_name?: string | null | undefined, create_date?: Date | null | undefined, create_by?: string | null | undefined, id?: string | null | undefined, file_name?: string | null | undefined, file_type?: string | null | undefined, file_size?: number | null | undefined, file_path?: string | null | undefined, description?: string | null | undefined, company_code?: string | null | undefined, enabled?: boolean | null | undefined, file?: any | null | undefined, files?: FileParameter[] | null | undefined, file2?: FileParameter | null | undefined): Observable<StatusMessageOfListOfUploadFileModel>;
    uploadFileVersion12(): Observable<StatusMessageOfListOfUploadFileModel>;
    viewFile(fileID?: string | undefined): Observable<FileResponse>;
}

@Injectable()
export class CommonContronllerClient extends APIBase implements ICommonContronllerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    listCompany(): Observable<Company[]> {
        let url_ = this.baseUrl + "/api/CommonContronller";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Company[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Company[]>;
        }));
    }

    protected processListCompany(response: HttpResponseBase): Observable<Company[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Company.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListStatusByModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pSysStatus);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatusByModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysStatus[]>;
        }));
    }

    protected processGetStatusByModule(response: HttpResponseBase): Observable<SysStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPermissionByCompany(): Observable<SysPermission[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListPermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionByCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionByCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysPermission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysPermission[]>;
        }));
    }

    protected processGetPermissionByCompany(response: HttpResponseBase): Observable<SysPermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysPermission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    excuteQueryString(model: QueryCommonModel): Observable<any[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ExcuteQueryString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExcuteQueryString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcuteQueryString(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processExcuteQueryString(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    excuteQueryStringV2(model: QueryCommonModel): Observable<StatusMessageOfString> {
        let url_ = this.baseUrl + "/api/CommonContronller/ExcuteQueryStringV2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExcuteQueryStringV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcuteQueryStringV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfString>;
        }));
    }

    protected processExcuteQueryStringV2(response: HttpResponseBase): Observable<StatusMessageOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadFileVersion11(table_name?: string | null | undefined, col_name?: string | null | undefined, create_date?: Date | null | undefined, create_by?: string | null | undefined, id?: string | null | undefined, file_name?: string | null | undefined, file_type?: string | null | undefined, file_size?: number | null | undefined, file_path?: string | null | undefined, description?: string | null | undefined, company_code?: string | null | undefined, enabled?: boolean | null | undefined, file?: any | null | undefined, files?: FileParameter[] | null | undefined, file2?: FileParameter | null | undefined): Observable<StatusMessageOfListOfUploadFileModel> {
        let url_ = this.baseUrl + "/api/CommonContronller/UploadFileVersion11?";
        if (table_name !== undefined && table_name !== null)
            url_ += "table_name=" + encodeURIComponent("" + table_name) + "&";
        if (col_name !== undefined && col_name !== null)
            url_ += "col_name=" + encodeURIComponent("" + col_name) + "&";
        if (create_date !== undefined && create_date !== null)
            url_ += "create_date=" + encodeURIComponent(create_date ? "" + create_date.toISOString() : "") + "&";
        if (create_by !== undefined && create_by !== null)
            url_ += "create_by=" + encodeURIComponent("" + create_by) + "&";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (file_name !== undefined && file_name !== null)
            url_ += "file_name=" + encodeURIComponent("" + file_name) + "&";
        if (file_type !== undefined && file_type !== null)
            url_ += "file_type=" + encodeURIComponent("" + file_type) + "&";
        if (file_size !== undefined && file_size !== null)
            url_ += "file_size=" + encodeURIComponent("" + file_size) + "&";
        if (file_path !== undefined && file_path !== null)
            url_ += "file_path=" + encodeURIComponent("" + file_path) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        if (company_code !== undefined && company_code !== null)
            url_ += "company_code=" + encodeURIComponent("" + company_code) + "&";
        if (enabled !== undefined && enabled !== null)
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        if (file !== undefined && file !== null)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );
        if (file2 !== null && file2 !== undefined)
            content_.append("file2", file2.data, file2.fileName ? file2.fileName : "file2");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUploadFileVersion11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFileVersion11(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfUploadFileModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfUploadFileModel>;
        }));
    }

    protected processUploadFileVersion11(response: HttpResponseBase): Observable<StatusMessageOfListOfUploadFileModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfUploadFileModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadFileVersion12(): Observable<StatusMessageOfListOfUploadFileModel> {
        let url_ = this.baseUrl + "/api/CommonContronller/UploadFileVersion12";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUploadFileVersion12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFileVersion12(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfUploadFileModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfUploadFileModel>;
        }));
    }

    protected processUploadFileVersion12(response: HttpResponseBase): Observable<StatusMessageOfListOfUploadFileModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfUploadFileModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    viewFile(fileID?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CommonContronller/ViewFile?";
        if (fileID === null)
            throw new Error("The parameter 'fileID' cannot be null.");
        else if (fileID !== undefined)
            url_ += "fileID=" + encodeURIComponent("" + fileID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processViewFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processViewFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class StatusMessageOfSysAction implements IStatusMessageOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysAction.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction | undefined;
    currentID?: string | undefined;
}

export class SysAction implements ISysAction {
    code?: string | undefined;
    nameVn?: string | undefined;
    nameOther?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    isDisable?: boolean | undefined;
    description?: string | undefined;
    url_1?: string | undefined;
    url_2?: string | undefined;
    url_3?: string | undefined;
    url_4?: string | undefined;
    isClocked?: boolean | undefined;
    codeGroup?: string | undefined;
    orderNo?: number | undefined;

    constructor(data?: ISysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.nameVn = _data["nameVn"];
            this.nameOther = _data["nameOther"];
            this.icon = _data["icon"];
            this.color = _data["color"];
            this.backgroundColor = _data["backgroundColor"];
            this.isDisable = _data["isDisable"];
            this.description = _data["description"];
            this.url_1 = _data["url_1"];
            this.url_2 = _data["url_2"];
            this.url_3 = _data["url_3"];
            this.url_4 = _data["url_4"];
            this.isClocked = _data["isClocked"];
            this.codeGroup = _data["codeGroup"];
            this.orderNo = _data["orderNo"];
        }
    }

    static fromJS(data: any): SysAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["nameVn"] = this.nameVn;
        data["nameOther"] = this.nameOther;
        data["icon"] = this.icon;
        data["color"] = this.color;
        data["backgroundColor"] = this.backgroundColor;
        data["isDisable"] = this.isDisable;
        data["description"] = this.description;
        data["url_1"] = this.url_1;
        data["url_2"] = this.url_2;
        data["url_3"] = this.url_3;
        data["url_4"] = this.url_4;
        data["isClocked"] = this.isClocked;
        data["codeGroup"] = this.codeGroup;
        data["orderNo"] = this.orderNo;
        return data;
    }
}

export interface ISysAction {
    code?: string | undefined;
    nameVn?: string | undefined;
    nameOther?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    isDisable?: boolean | undefined;
    description?: string | undefined;
    url_1?: string | undefined;
    url_2?: string | undefined;
    url_3?: string | undefined;
    url_4?: string | undefined;
    isClocked?: boolean | undefined;
    codeGroup?: string | undefined;
    orderNo?: number | undefined;
}

export class StatusMessageOfObject implements IStatusMessageOfObject {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"];
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfObject {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfObject {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysDropDownAction implements IStatusMessageOfSysDropDownAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysDropDownAction | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysDropDownAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysDropDownAction.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysDropDownAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysDropDownAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysDropDownAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysDropDownAction | undefined;
    currentID?: string | undefined;
}

export class SysDropDownAction implements ISysDropDownAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;

    constructor(data?: ISysDropDownAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.codeAction = _data["codeAction"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
            this.isClocked = _data["isClocked"];
        }
    }

    static fromJS(data: any): SysDropDownAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysDropDownAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["codeAction"] = this.codeAction;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        data["isClocked"] = this.isClocked;
        return data;
    }
}

export interface ISysDropDownAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
}

export class StatusMessageOfListOfSysAction implements IStatusMessageOfListOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysAction.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction[] | undefined;
    currentID?: string | undefined;
}

export class SysGroupAction implements ISysGroupAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
    isDropDown?: boolean | undefined;
    listChildAction?: SysAction[] | undefined;

    constructor(data?: ISysGroupAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.codeAction = _data["codeAction"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
            this.isClocked = _data["isClocked"];
            this.isDropDown = _data["isDropDown"];
            if (Array.isArray(_data["listChildAction"])) {
                this.listChildAction = [] as any;
                for (let item of _data["listChildAction"])
                    this.listChildAction!.push(SysAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SysGroupAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysGroupAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["codeAction"] = this.codeAction;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        data["isClocked"] = this.isClocked;
        data["isDropDown"] = this.isDropDown;
        if (Array.isArray(this.listChildAction)) {
            data["listChildAction"] = [];
            for (let item of this.listChildAction)
                data["listChildAction"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISysGroupAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
    isDropDown?: boolean | undefined;
    listChildAction?: SysAction[] | undefined;
}

export class StatusMessageOfSysGenRowTable implements IStatusMessageOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysGenRowTable.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable | undefined;
    currentID?: string | undefined;
}

export class SysGenRowTable implements ISysGenRowTable {
    id?: string | undefined;
    table_name?: string | undefined;
    dataField?: string | undefined;
    caption?: string | undefined;
    caption_VN?: string | undefined;
    name?: string | undefined;
    dataType?: string | undefined;
    format?: string | undefined;
    width?: number | undefined;
    visible?: boolean | undefined;
    minWidth?: number | undefined;
    alignment?: string | undefined;
    allowEditing?: boolean | undefined;
    allowFiltering?: boolean | undefined;
    allowFixing?: boolean | undefined;
    allowGrouping?: boolean | undefined;
    allowHeaderFiltering?: boolean | undefined;
    allowHiding?: boolean | undefined;
    allowSearch?: boolean | undefined;
    allowSorting?: boolean | undefined;
    autoExpandGroup?: boolean | undefined;
    columns?: SysGenRowTable[] | undefined;
    column_child?: string | undefined;
    cssClass?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;

    constructor(data?: ISysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.dataField = _data["dataField"];
            this.caption = _data["caption"];
            this.caption_VN = _data["caption_VN"];
            this.name = _data["name"];
            this.dataType = _data["dataType"];
            this.format = _data["format"];
            this.width = _data["width"];
            this.visible = _data["visible"];
            this.minWidth = _data["minWidth"];
            this.alignment = _data["alignment"];
            this.allowEditing = _data["allowEditing"];
            this.allowFiltering = _data["allowFiltering"];
            this.allowFixing = _data["allowFixing"];
            this.allowGrouping = _data["allowGrouping"];
            this.allowHeaderFiltering = _data["allowHeaderFiltering"];
            this.allowHiding = _data["allowHiding"];
            this.allowSearch = _data["allowSearch"];
            this.allowSorting = _data["allowSorting"];
            this.autoExpandGroup = _data["autoExpandGroup"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(SysGenRowTable.fromJS(item));
            }
            this.column_child = _data["column_child"];
            this.cssClass = _data["cssClass"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.companyCode = _data["companyCode"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new SysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["dataField"] = this.dataField;
        data["caption"] = this.caption;
        data["caption_VN"] = this.caption_VN;
        data["name"] = this.name;
        data["dataType"] = this.dataType;
        data["format"] = this.format;
        data["width"] = this.width;
        data["visible"] = this.visible;
        data["minWidth"] = this.minWidth;
        data["alignment"] = this.alignment;
        data["allowEditing"] = this.allowEditing;
        data["allowFiltering"] = this.allowFiltering;
        data["allowFixing"] = this.allowFixing;
        data["allowGrouping"] = this.allowGrouping;
        data["allowHeaderFiltering"] = this.allowHeaderFiltering;
        data["allowHiding"] = this.allowHiding;
        data["allowSearch"] = this.allowSearch;
        data["allowSorting"] = this.allowSorting;
        data["autoExpandGroup"] = this.autoExpandGroup;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["column_child"] = this.column_child;
        data["cssClass"] = this.cssClass;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["companyCode"] = this.companyCode;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        return data;
    }
}

export interface ISysGenRowTable {
    id?: string | undefined;
    table_name?: string | undefined;
    dataField?: string | undefined;
    caption?: string | undefined;
    caption_VN?: string | undefined;
    name?: string | undefined;
    dataType?: string | undefined;
    format?: string | undefined;
    width?: number | undefined;
    visible?: boolean | undefined;
    minWidth?: number | undefined;
    alignment?: string | undefined;
    allowEditing?: boolean | undefined;
    allowFiltering?: boolean | undefined;
    allowFixing?: boolean | undefined;
    allowGrouping?: boolean | undefined;
    allowHeaderFiltering?: boolean | undefined;
    allowHiding?: boolean | undefined;
    allowSearch?: boolean | undefined;
    allowSorting?: boolean | undefined;
    autoExpandGroup?: boolean | undefined;
    columns?: SysGenRowTable[] | undefined;
    column_child?: string | undefined;
    cssClass?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
}

export class StatusMessageOfListOfSysGenRowTable implements IStatusMessageOfListOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysGenRowTable.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfListOfSysMenu implements IStatusMessageOfListOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysMenu.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu[] | undefined;
    currentID?: string | undefined;
}

export class SysMenu implements ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    nameVN?: string | undefined;
    icon?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;
    action1?: string | undefined;
    action2?: string | undefined;
    action3?: string | undefined;
    action4?: string | undefined;
    action5?: string | undefined;
    action6?: string | undefined;
    action7?: string | undefined;

    constructor(data?: ISysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuid = _data["menuid"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.nameVN = _data["nameVN"];
            this.icon = _data["icon"];
            this.active = _data["active"];
            this.isParent = _data["isParent"];
            this.menuIDParent = _data["menuIDParent"];
            this.defaultActive = _data["defaultActive"];
            this.moduleApp = _data["moduleApp"];
            this.action1 = _data["action1"];
            this.action2 = _data["action2"];
            this.action3 = _data["action3"];
            this.action4 = _data["action4"];
            this.action5 = _data["action5"];
            this.action6 = _data["action6"];
            this.action7 = _data["action7"];
        }
    }

    static fromJS(data: any): SysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new SysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuid"] = this.menuid;
        data["url"] = this.url;
        data["name"] = this.name;
        data["nameVN"] = this.nameVN;
        data["icon"] = this.icon;
        data["active"] = this.active;
        data["isParent"] = this.isParent;
        data["menuIDParent"] = this.menuIDParent;
        data["defaultActive"] = this.defaultActive;
        data["moduleApp"] = this.moduleApp;
        data["action1"] = this.action1;
        data["action2"] = this.action2;
        data["action3"] = this.action3;
        data["action4"] = this.action4;
        data["action5"] = this.action5;
        data["action6"] = this.action6;
        data["action7"] = this.action7;
        return data;
    }
}

export interface ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    nameVN?: string | undefined;
    icon?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;
    action1?: string | undefined;
    action2?: string | undefined;
    action3?: string | undefined;
    action4?: string | undefined;
    action5?: string | undefined;
    action6?: string | undefined;
    action7?: string | undefined;
}

export class StatusMessageOfSysMenu implements IStatusMessageOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysMenu.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysVoucherFormColumn implements IStatusMessageOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysVoucherFormColumn.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn | undefined;
    currentID?: string | undefined;
}

export class SysVoucherFormColumn implements ISysVoucherFormColumn {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    labelModel?: string | undefined;
    edit?: boolean | undefined;
    labelControl?: string | undefined;
    labelControlVN?: string | undefined;
    labelControlCN?: string | undefined;
    labelRequired?: boolean | undefined;
    visible?: boolean | undefined;
    disabled?: boolean | undefined;
    readOnly?: boolean | undefined;
    required?: boolean | undefined;
    showClearButton?: boolean | undefined;
    label?: string | undefined;
    placeholder?: string | undefined;
    mode?: string | undefined;
    mask?: string | undefined;
    maskRules?: string | undefined;
    groupId?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    typeControl?: string | undefined;
    format?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;
    number_order?: number | undefined;
    displayFormat?: string | undefined;
    type?: string | undefined;
    query?: string | undefined;

    constructor(data?: ISysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.code = _data["code"];
            this.labelModel = _data["labelModel"];
            this.edit = _data["edit"];
            this.labelControl = _data["labelControl"];
            this.labelControlVN = _data["labelControlVN"];
            this.labelControlCN = _data["labelControlCN"];
            this.labelRequired = _data["labelRequired"];
            this.visible = _data["visible"];
            this.disabled = _data["disabled"];
            this.readOnly = _data["readOnly"];
            this.required = _data["required"];
            this.showClearButton = _data["showClearButton"];
            this.label = _data["label"];
            this.placeholder = _data["placeholder"];
            this.mode = _data["mode"];
            this.mask = _data["mask"];
            this.maskRules = _data["maskRules"];
            this.groupId = _data["groupId"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.companyCode = _data["companyCode"];
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.typeControl = _data["typeControl"];
            this.format = _data["format"];
            this.description = _data["description"];
            this.description1 = _data["description1"];
            this.description2 = _data["description2"];
            this.description3 = _data["description3"];
            this.number_order = _data["number_order"];
            this.displayFormat = _data["displayFormat"];
            this.type = _data["type"];
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): SysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new SysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["code"] = this.code;
        data["labelModel"] = this.labelModel;
        data["edit"] = this.edit;
        data["labelControl"] = this.labelControl;
        data["labelControlVN"] = this.labelControlVN;
        data["labelControlCN"] = this.labelControlCN;
        data["labelRequired"] = this.labelRequired;
        data["visible"] = this.visible;
        data["disabled"] = this.disabled;
        data["readOnly"] = this.readOnly;
        data["required"] = this.required;
        data["showClearButton"] = this.showClearButton;
        data["label"] = this.label;
        data["placeholder"] = this.placeholder;
        data["mode"] = this.mode;
        data["mask"] = this.mask;
        data["maskRules"] = this.maskRules;
        data["groupId"] = this.groupId;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["companyCode"] = this.companyCode;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["typeControl"] = this.typeControl;
        data["format"] = this.format;
        data["description"] = this.description;
        data["description1"] = this.description1;
        data["description2"] = this.description2;
        data["description3"] = this.description3;
        data["number_order"] = this.number_order;
        data["displayFormat"] = this.displayFormat;
        data["type"] = this.type;
        data["query"] = this.query;
        return data;
    }
}

export interface ISysVoucherFormColumn {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    labelModel?: string | undefined;
    edit?: boolean | undefined;
    labelControl?: string | undefined;
    labelControlVN?: string | undefined;
    labelControlCN?: string | undefined;
    labelRequired?: boolean | undefined;
    visible?: boolean | undefined;
    disabled?: boolean | undefined;
    readOnly?: boolean | undefined;
    required?: boolean | undefined;
    showClearButton?: boolean | undefined;
    label?: string | undefined;
    placeholder?: string | undefined;
    mode?: string | undefined;
    mask?: string | undefined;
    maskRules?: string | undefined;
    groupId?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    typeControl?: string | undefined;
    format?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;
    number_order?: number | undefined;
    displayFormat?: string | undefined;
    type?: string | undefined;
    query?: string | undefined;
}

export class StatusMessageOfListOfSysVoucherFormColumn implements IStatusMessageOfListOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysVoucherFormColumn.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysVoucherFormGroup implements IStatusMessageOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysVoucherFormGroup.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup | undefined;
    currentID?: string | undefined;
}

export class SysVoucherFormGroup implements ISysVoucherFormGroup {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    group_id?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;

    constructor(data?: ISysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.code = _data["code"];
            this.name1 = _data["name1"];
            this.name2 = _data["name2"];
            this.name3 = _data["name3"];
            this.number_order = _data["number_order"];
            this.group_id = _data["group_id"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.companyCode = _data["companyCode"];
            this.description = _data["description"];
            this.description1 = _data["description1"];
            this.description2 = _data["description2"];
            this.description3 = _data["description3"];
        }
    }

    static fromJS(data: any): SysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["code"] = this.code;
        data["name1"] = this.name1;
        data["name2"] = this.name2;
        data["name3"] = this.name3;
        data["number_order"] = this.number_order;
        data["group_id"] = this.group_id;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["companyCode"] = this.companyCode;
        data["description"] = this.description;
        data["description1"] = this.description1;
        data["description2"] = this.description2;
        data["description3"] = this.description3;
        return data;
    }
}

export interface ISysVoucherFormGroup {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    group_id?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;
}

export class StatusMessageOfListOfSysVoucherFormGroup implements IStatusMessageOfListOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysVoucherFormGroup.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup[] | undefined;
    currentID?: string | undefined;
}

export class CurrentJobPosition implements ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;

    constructor(data?: ICurrentJobPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.jobDescription = _data["jobDescription"];
            this.departmentOrTeam = _data["departmentOrTeam"];
            this.positionAndLevel = _data["positionAndLevel"];
            this.workSchedule = _data["workSchedule"];
            this.currentProjects = _data["currentProjects"];
            this.goalsAndDevelopment = _data["goalsAndDevelopment"];
        }
    }

    static fromJS(data: any): CurrentJobPosition {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentJobPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["jobDescription"] = this.jobDescription;
        data["departmentOrTeam"] = this.departmentOrTeam;
        data["positionAndLevel"] = this.positionAndLevel;
        data["workSchedule"] = this.workSchedule;
        data["currentProjects"] = this.currentProjects;
        data["goalsAndDevelopment"] = this.goalsAndDevelopment;
        return data;
    }
}

export interface ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;
}

export class SalaryAndBenefits implements ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;

    constructor(data?: ISalaryAndBenefits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.salary = _data["salary"];
            this.benefits = _data["benefits"];
            this.wagesAndPerks = _data["wagesAndPerks"];
            this.compensationPackageAmount = _data["compensationPackageAmount"];
            this.compensationPackage = _data["compensationPackage"];
            this.compensationPackageAmount1 = _data["compensationPackageAmount1"];
            this.compensationPackage1 = _data["compensationPackage1"];
            this.compensationPackageAmount2 = _data["compensationPackageAmount2"];
            this.compensationPackage2 = _data["compensationPackage2"];
            this.compensationPackageAmount3 = _data["compensationPackageAmount3"];
            this.compensationPackage3 = _data["compensationPackage3"];
            this.insuranceCoverage = _data["insuranceCoverage"];
            this.allowancesAndAidsAmount = _data["allowancesAndAidsAmount"];
            this.allowancesAndAids = _data["allowancesAndAids"];
            this.allowancesAndAidsAmount1 = _data["allowancesAndAidsAmount1"];
            this.allowancesAndAids1 = _data["allowancesAndAids1"];
            this.allowancesAndAidsAmount2 = _data["allowancesAndAidsAmount2"];
            this.allowancesAndAids2 = _data["allowancesAndAids2"];
            this.allowancesAndAidsAmount3 = _data["allowancesAndAidsAmount3"];
            this.allowancesAndAids3 = _data["allowancesAndAids3"];
        }
    }

    static fromJS(data: any): SalaryAndBenefits {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryAndBenefits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["salary"] = this.salary;
        data["benefits"] = this.benefits;
        data["wagesAndPerks"] = this.wagesAndPerks;
        data["compensationPackageAmount"] = this.compensationPackageAmount;
        data["compensationPackage"] = this.compensationPackage;
        data["compensationPackageAmount1"] = this.compensationPackageAmount1;
        data["compensationPackage1"] = this.compensationPackage1;
        data["compensationPackageAmount2"] = this.compensationPackageAmount2;
        data["compensationPackage2"] = this.compensationPackage2;
        data["compensationPackageAmount3"] = this.compensationPackageAmount3;
        data["compensationPackage3"] = this.compensationPackage3;
        data["insuranceCoverage"] = this.insuranceCoverage;
        data["allowancesAndAidsAmount"] = this.allowancesAndAidsAmount;
        data["allowancesAndAids"] = this.allowancesAndAids;
        data["allowancesAndAidsAmount1"] = this.allowancesAndAidsAmount1;
        data["allowancesAndAids1"] = this.allowancesAndAids1;
        data["allowancesAndAidsAmount2"] = this.allowancesAndAidsAmount2;
        data["allowancesAndAids2"] = this.allowancesAndAids2;
        data["allowancesAndAidsAmount3"] = this.allowancesAndAidsAmount3;
        data["allowancesAndAids3"] = this.allowancesAndAids3;
        return data;
    }
}

export interface ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;
}

export class WorkHistory implements IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;

    constructor(data?: IWorkHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.companyAndPosition = _data["companyAndPosition"];
            this.workHistoryStart = _data["workHistoryStart"] ? new Date(_data["workHistoryStart"].toString()) : <any>undefined;
            this.workHistoryEnd = _data["workHistoryEnd"] ? new Date(_data["workHistoryEnd"].toString()) : <any>undefined;
            this.timeWorked = _data["timeWorked"];
            this.jobdeScription = _data["jobdeScription"];
            this.achievementSkills = _data["achievementSkills"];
            this.reasonForChange = _data["reasonForChange"];
        }
    }

    static fromJS(data: any): WorkHistory {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["companyAndPosition"] = this.companyAndPosition;
        data["workHistoryStart"] = this.workHistoryStart ? this.workHistoryStart.toISOString() : <any>undefined;
        data["workHistoryEnd"] = this.workHistoryEnd ? this.workHistoryEnd.toISOString() : <any>undefined;
        data["timeWorked"] = this.timeWorked;
        data["jobdeScription"] = this.jobdeScription;
        data["achievementSkills"] = this.achievementSkills;
        data["reasonForChange"] = this.reasonForChange;
        return data;
    }
}

export interface IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;
}

export class StatusMessageOfMovieCommentModel implements IStatusMessageOfMovieCommentModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieCommentModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMovieCommentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MovieCommentModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMovieCommentModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMovieCommentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMovieCommentModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieCommentModel | undefined;
    currentID?: string | undefined;
}

export class MovieCommentModel implements IMovieCommentModel {
    id?: string | undefined;
    user_id?: string | undefined;
    movie_id?: string | undefined;
    create_date?: Date | undefined;
    is_delete?: boolean;
    movie_url?: string | undefined;
    content?: string | undefined;
    id_parent?: boolean | undefined;
    parent_id?: string | undefined;
    form_date?: Date | undefined;
    to_date?: Date | undefined;

    constructor(data?: IMovieCommentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_id = _data["user_id"];
            this.movie_id = _data["movie_id"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.is_delete = _data["is_delete"];
            this.movie_url = _data["movie_url"];
            this.content = _data["content"];
            this.id_parent = _data["id_parent"];
            this.parent_id = _data["parent_id"];
            this.form_date = _data["form_date"] ? new Date(_data["form_date"].toString()) : <any>undefined;
            this.to_date = _data["to_date"] ? new Date(_data["to_date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MovieCommentModel {
        data = typeof data === 'object' ? data : {};
        let result = new MovieCommentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_id"] = this.user_id;
        data["movie_id"] = this.movie_id;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["is_delete"] = this.is_delete;
        data["movie_url"] = this.movie_url;
        data["content"] = this.content;
        data["id_parent"] = this.id_parent;
        data["parent_id"] = this.parent_id;
        data["form_date"] = this.form_date ? this.form_date.toISOString() : <any>undefined;
        data["to_date"] = this.to_date ? this.to_date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMovieCommentModel {
    id?: string | undefined;
    user_id?: string | undefined;
    movie_id?: string | undefined;
    create_date?: Date | undefined;
    is_delete?: boolean;
    movie_url?: string | undefined;
    content?: string | undefined;
    id_parent?: boolean | undefined;
    parent_id?: string | undefined;
    form_date?: Date | undefined;
    to_date?: Date | undefined;
}

export class StatusMessageOfListOfMovieCommentModel implements IStatusMessageOfListOfMovieCommentModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieCommentModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfMovieCommentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MovieCommentModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfMovieCommentModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfMovieCommentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfMovieCommentModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieCommentModel[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfMovieModel implements IStatusMessageOfMovieModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMovieModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MovieModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMovieModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMovieModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMovieModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieModel | undefined;
    currentID?: string | undefined;
}

export class MovieModel implements IMovieModel {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    genres_id?: string | undefined;
    thumbnail_url?: string | undefined;
    trailer_url?: string | undefined;
    movie_url?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    is_delete?: boolean | undefined;
    is_active?: boolean | undefined;
    national_id?: string | undefined;
    language_id?: string | undefined;
    release_year?: number | undefined;
    duration?: number | undefined;
    page_current?: number | undefined;
    item_take?: number | undefined;

    constructor(data?: IMovieModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.genres_id = _data["genres_id"];
            this.thumbnail_url = _data["thumbnail_url"];
            this.trailer_url = _data["trailer_url"];
            this.movie_url = _data["movie_url"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.is_delete = _data["is_delete"];
            this.is_active = _data["is_active"];
            this.national_id = _data["national_id"];
            this.language_id = _data["language_id"];
            this.release_year = _data["release_year"];
            this.duration = _data["duration"];
            this.page_current = _data["page_current"];
            this.item_take = _data["item_take"];
        }
    }

    static fromJS(data: any): MovieModel {
        data = typeof data === 'object' ? data : {};
        let result = new MovieModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["genres_id"] = this.genres_id;
        data["thumbnail_url"] = this.thumbnail_url;
        data["trailer_url"] = this.trailer_url;
        data["movie_url"] = this.movie_url;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["is_delete"] = this.is_delete;
        data["is_active"] = this.is_active;
        data["national_id"] = this.national_id;
        data["language_id"] = this.language_id;
        data["release_year"] = this.release_year;
        data["duration"] = this.duration;
        data["page_current"] = this.page_current;
        data["item_take"] = this.item_take;
        return data;
    }
}

export interface IMovieModel {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    genres_id?: string | undefined;
    thumbnail_url?: string | undefined;
    trailer_url?: string | undefined;
    movie_url?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    is_delete?: boolean | undefined;
    is_active?: boolean | undefined;
    national_id?: string | undefined;
    language_id?: string | undefined;
    release_year?: number | undefined;
    duration?: number | undefined;
    page_current?: number | undefined;
    item_take?: number | undefined;
}

export class StatusMessageOfMovieParamModel implements IStatusMessageOfMovieParamModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieParamModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMovieParamModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MovieParamModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMovieParamModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMovieParamModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMovieParamModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieParamModel | undefined;
    currentID?: string | undefined;
}

export class MovieParamModel extends MovieModel implements IMovieParamModel {
    curret_idx_item?: number | undefined;
    national_name?: string | undefined;
    genres_name?: string | undefined;
    language_name?: string | undefined;

    constructor(data?: IMovieParamModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.curret_idx_item = _data["curret_idx_item"];
            this.national_name = _data["national_name"];
            this.genres_name = _data["genres_name"];
            this.language_name = _data["language_name"];
        }
    }

    static override fromJS(data: any): MovieParamModel {
        data = typeof data === 'object' ? data : {};
        let result = new MovieParamModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["curret_idx_item"] = this.curret_idx_item;
        data["national_name"] = this.national_name;
        data["genres_name"] = this.genres_name;
        data["language_name"] = this.language_name;
        super.toJSON(data);
        return data;
    }
}

export interface IMovieParamModel extends IMovieModel {
    curret_idx_item?: number | undefined;
    national_name?: string | undefined;
    genres_name?: string | undefined;
    language_name?: string | undefined;
}

export class StatusMessageOfListOfMovieModel implements IStatusMessageOfListOfMovieModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfMovieModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MovieModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfMovieModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfMovieModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfMovieModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieModel[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfMovieFavoritesModel implements IStatusMessageOfMovieFavoritesModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieFavoritesModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMovieFavoritesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MovieFavoritesModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMovieFavoritesModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMovieFavoritesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMovieFavoritesModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieFavoritesModel | undefined;
    currentID?: string | undefined;
}

export class MovieFavoritesModel implements IMovieFavoritesModel {
    id?: string | undefined;
    user_id?: string | undefined;
    movie_id?: string | undefined;
    create_date?: Date | undefined;
    is_delete?: boolean;
    movie_name?: string | undefined;
    movie_url?: string | undefined;
    movie_description?: string | undefined;
    movie_thumbnail_url?: string | undefined;
    delete_at?: Date | undefined;

    constructor(data?: IMovieFavoritesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_id = _data["user_id"];
            this.movie_id = _data["movie_id"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.is_delete = _data["is_delete"];
            this.movie_name = _data["movie_name"];
            this.movie_url = _data["movie_url"];
            this.movie_description = _data["movie_description"];
            this.movie_thumbnail_url = _data["movie_thumbnail_url"];
            this.delete_at = _data["delete_at"] ? new Date(_data["delete_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MovieFavoritesModel {
        data = typeof data === 'object' ? data : {};
        let result = new MovieFavoritesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_id"] = this.user_id;
        data["movie_id"] = this.movie_id;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["is_delete"] = this.is_delete;
        data["movie_name"] = this.movie_name;
        data["movie_url"] = this.movie_url;
        data["movie_description"] = this.movie_description;
        data["movie_thumbnail_url"] = this.movie_thumbnail_url;
        data["delete_at"] = this.delete_at ? this.delete_at.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMovieFavoritesModel {
    id?: string | undefined;
    user_id?: string | undefined;
    movie_id?: string | undefined;
    create_date?: Date | undefined;
    is_delete?: boolean;
    movie_name?: string | undefined;
    movie_url?: string | undefined;
    movie_description?: string | undefined;
    movie_thumbnail_url?: string | undefined;
    delete_at?: Date | undefined;
}

export class StatusMessageOfListOfMovieFavoritesModel implements IStatusMessageOfListOfMovieFavoritesModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieFavoritesModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfMovieFavoritesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MovieFavoritesModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfMovieFavoritesModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfMovieFavoritesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfMovieFavoritesModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieFavoritesModel[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfMovieGenresModel implements IStatusMessageOfMovieGenresModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieGenresModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMovieGenresModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MovieGenresModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMovieGenresModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMovieGenresModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMovieGenresModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieGenresModel | undefined;
    currentID?: string | undefined;
}

export class MovieGenresModel implements IMovieGenresModel {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    genres_id?: string | undefined;
    is_parent?: boolean | undefined;

    constructor(data?: IMovieGenresModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.genres_id = _data["genres_id"];
            this.is_parent = _data["is_parent"];
        }
    }

    static fromJS(data: any): MovieGenresModel {
        data = typeof data === 'object' ? data : {};
        let result = new MovieGenresModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["genres_id"] = this.genres_id;
        data["is_parent"] = this.is_parent;
        return data;
    }
}

export interface IMovieGenresModel {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    genres_id?: string | undefined;
    is_parent?: boolean | undefined;
}

export class StatusMessageOfListOfMovieGenresModel implements IStatusMessageOfListOfMovieGenresModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieGenresModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfMovieGenresModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MovieGenresModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfMovieGenresModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfMovieGenresModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfMovieGenresModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieGenresModel[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfMovieReivewModel implements IStatusMessageOfMovieReivewModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieReivewModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMovieReivewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MovieReivewModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMovieReivewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMovieReivewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMovieReivewModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieReivewModel | undefined;
    currentID?: string | undefined;
}

export class MovieReivewModel implements IMovieReivewModel {
    id?: string | undefined;
    user_id?: string | undefined;
    user_name?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    rating?: number | undefined;
    content?: string | undefined;
    movie_id?: string | undefined;
    from_date?: Date | undefined;
    to_date?: Date | undefined;
    skip?: number | undefined;
    take?: number | undefined;

    constructor(data?: IMovieReivewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_id = _data["user_id"];
            this.user_name = _data["user_name"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.rating = _data["rating"];
            this.content = _data["content"];
            this.movie_id = _data["movie_id"];
            this.from_date = _data["from_date"] ? new Date(_data["from_date"].toString()) : <any>undefined;
            this.to_date = _data["to_date"] ? new Date(_data["to_date"].toString()) : <any>undefined;
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): MovieReivewModel {
        data = typeof data === 'object' ? data : {};
        let result = new MovieReivewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_id"] = this.user_id;
        data["user_name"] = this.user_name;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["content"] = this.content;
        data["movie_id"] = this.movie_id;
        data["from_date"] = this.from_date ? this.from_date.toISOString() : <any>undefined;
        data["to_date"] = this.to_date ? this.to_date.toISOString() : <any>undefined;
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IMovieReivewModel {
    id?: string | undefined;
    user_id?: string | undefined;
    user_name?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    rating?: number | undefined;
    content?: string | undefined;
    movie_id?: string | undefined;
    from_date?: Date | undefined;
    to_date?: Date | undefined;
    skip?: number | undefined;
    take?: number | undefined;
}

export class StatusMessageOfListOfMovieReivewModel implements IStatusMessageOfListOfMovieReivewModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieReivewModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfMovieReivewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MovieReivewModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfMovieReivewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfMovieReivewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfMovieReivewModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieReivewModel[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfMovieWatchHistoryModel implements IStatusMessageOfMovieWatchHistoryModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieWatchHistoryModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMovieWatchHistoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MovieWatchHistoryModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMovieWatchHistoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMovieWatchHistoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMovieWatchHistoryModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieWatchHistoryModel | undefined;
    currentID?: string | undefined;
}

export class MovieWatchHistoryModel implements IMovieWatchHistoryModel {
    id?: string | undefined;
    user_id?: string | undefined;
    user_name?: string | undefined;
    create_date?: Date | undefined;
    movie_id?: string | undefined;
    movie_name?: string | undefined;
    movie_url?: string | undefined;
    movie_description?: string | undefined;
    movie_thumbnail_url?: string | undefined;
    time_view?: number | undefined;
    is_delete?: boolean | undefined;
    from_date?: Date | undefined;
    to_date?: Date | undefined;
    skip?: number | undefined;
    take?: number | undefined;

    constructor(data?: IMovieWatchHistoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_id = _data["user_id"];
            this.user_name = _data["user_name"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.movie_id = _data["movie_id"];
            this.movie_name = _data["movie_name"];
            this.movie_url = _data["movie_url"];
            this.movie_description = _data["movie_description"];
            this.movie_thumbnail_url = _data["movie_thumbnail_url"];
            this.time_view = _data["time_view"];
            this.is_delete = _data["is_delete"];
            this.from_date = _data["from_date"] ? new Date(_data["from_date"].toString()) : <any>undefined;
            this.to_date = _data["to_date"] ? new Date(_data["to_date"].toString()) : <any>undefined;
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): MovieWatchHistoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new MovieWatchHistoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_id"] = this.user_id;
        data["user_name"] = this.user_name;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["movie_id"] = this.movie_id;
        data["movie_name"] = this.movie_name;
        data["movie_url"] = this.movie_url;
        data["movie_description"] = this.movie_description;
        data["movie_thumbnail_url"] = this.movie_thumbnail_url;
        data["time_view"] = this.time_view;
        data["is_delete"] = this.is_delete;
        data["from_date"] = this.from_date ? this.from_date.toISOString() : <any>undefined;
        data["to_date"] = this.to_date ? this.to_date.toISOString() : <any>undefined;
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IMovieWatchHistoryModel {
    id?: string | undefined;
    user_id?: string | undefined;
    user_name?: string | undefined;
    create_date?: Date | undefined;
    movie_id?: string | undefined;
    movie_name?: string | undefined;
    movie_url?: string | undefined;
    movie_description?: string | undefined;
    movie_thumbnail_url?: string | undefined;
    time_view?: number | undefined;
    is_delete?: boolean | undefined;
    from_date?: Date | undefined;
    to_date?: Date | undefined;
    skip?: number | undefined;
    take?: number | undefined;
}

export class StatusMessageOfListOfMovieWatchHistoryModel implements IStatusMessageOfListOfMovieWatchHistoryModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieWatchHistoryModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfMovieWatchHistoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MovieWatchHistoryModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfMovieWatchHistoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfMovieWatchHistoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfMovieWatchHistoryModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MovieWatchHistoryModel[] | undefined;
    currentID?: string | undefined;
}

export class AccountClientLoginParamsModel implements IAccountClientLoginParamsModel {
    account?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;

    constructor(data?: IAccountClientLoginParamsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.companyCode = _data["companyCode"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.ip_address = _data["ip_address"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): AccountClientLoginParamsModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientLoginParamsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["companyCode"] = this.companyCode;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["ip_address"] = this.ip_address;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IAccountClientLoginParamsModel {
    account?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
}

export class AccountClientProfileModel implements IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;

    constructor(data?: IAccountClientProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            this.userInfo = _data["userInfo"] ? UserInfo.fromJS(_data["userInfo"]) : <any>undefined;
            this.token = _data["token"] ? TOKEN.fromJS(_data["token"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountClientProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["userInfo"] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
        data["token"] = this.token ? this.token.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;
}

export class Account implements IAccount {
    account?: string | undefined;
    password?: string | undefined;
    password1?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;
    language?: string | undefined;
    status_f?: string | undefined;
    type_account_f?: string | undefined;
    companyCode_f?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.password1 = _data["password1"];
            this.status = _data["status"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.type_account = _data["type_account"];
            this.token = _data["token"];
            this.codePermision = _data["codePermision"];
            this.companyCode = _data["companyCode"];
            this.namePermision = _data["namePermision"];
            this.language = _data["language"];
            this.status_f = _data["status_f"];
            this.type_account_f = _data["type_account_f"];
            this.companyCode_f = _data["companyCode_f"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["password1"] = this.password1;
        data["status"] = this.status;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["type_account"] = this.type_account;
        data["token"] = this.token;
        data["codePermision"] = this.codePermision;
        data["companyCode"] = this.companyCode;
        data["namePermision"] = this.namePermision;
        data["language"] = this.language;
        data["status_f"] = this.status_f;
        data["type_account_f"] = this.type_account_f;
        data["companyCode_f"] = this.companyCode_f;
        return data;
    }
}

export interface IAccount {
    account?: string | undefined;
    password?: string | undefined;
    password1?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;
    language?: string | undefined;
    status_f?: string | undefined;
    type_account_f?: string | undefined;
    companyCode_f?: string | undefined;
}

export class UserInfo implements IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        return data;
    }
}

export interface IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
}

export class TOKEN implements ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;

    constructor(data?: ITOKEN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.username = _data["username"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.last_date_connect = _data["last_date_connect"] ? new Date(_data["last_date_connect"].toString()) : <any>undefined;
            this.is_connecting = _data["is_connecting"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ip_address = _data["ip_address"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.connectionSignalID = _data["connectionSignalID"];
        }
    }

    static fromJS(data: any): TOKEN {
        data = typeof data === 'object' ? data : {};
        let result = new TOKEN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["username"] = this.username;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["last_date_connect"] = this.last_date_connect ? this.last_date_connect.toISOString() : <any>undefined;
        data["is_connecting"] = this.is_connecting;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ip_address"] = this.ip_address;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["connectionSignalID"] = this.connectionSignalID;
        return data;
    }
}

export interface ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;
}

export class StatusMessageOfAccountClientProfileModel implements IStatusMessageOfAccountClientProfileModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: AccountClientProfileModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfAccountClientProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? AccountClientProfileModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfAccountClientProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfAccountClientProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfAccountClientProfileModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: AccountClientProfileModel | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfListOfUserInfoGetListModel implements IStatusMessageOfListOfUserInfoGetListModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: UserInfoGetListModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfUserInfoGetListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserInfoGetListModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfUserInfoGetListModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfUserInfoGetListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfUserInfoGetListModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: UserInfoGetListModel[] | undefined;
    currentID?: string | undefined;
}

export class UserInfoGetListModel extends UserInfo implements IUserInfoGetListModel {
    status?: string | undefined;
    lock_date?: Date | undefined;
    last_enter?: Date | undefined;
    email?: string | undefined;
    type_account?: string | undefined;
    namePermision?: string | undefined;
    status_f?: string | undefined;
    type_account_f?: string | undefined;

    constructor(data?: IUserInfoGetListModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.status = _data["status"];
            this.lock_date = _data["lock_date"] ? new Date(_data["lock_date"].toString()) : <any>undefined;
            this.last_enter = _data["last_enter"] ? new Date(_data["last_enter"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.type_account = _data["type_account"];
            this.namePermision = _data["namePermision"];
            this.status_f = _data["status_f"];
            this.type_account_f = _data["type_account_f"];
        }
    }

    static override fromJS(data: any): UserInfoGetListModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoGetListModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["lock_date"] = this.lock_date ? this.lock_date.toISOString() : <any>undefined;
        data["last_enter"] = this.last_enter ? this.last_enter.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["type_account"] = this.type_account;
        data["namePermision"] = this.namePermision;
        data["status_f"] = this.status_f;
        data["type_account_f"] = this.type_account_f;
        super.toJSON(data);
        return data;
    }
}

export interface IUserInfoGetListModel extends IUserInfo {
    status?: string | undefined;
    lock_date?: Date | undefined;
    last_enter?: Date | undefined;
    email?: string | undefined;
    type_account?: string | undefined;
    namePermision?: string | undefined;
    status_f?: string | undefined;
    type_account_f?: string | undefined;
}

export class StatusMessageOfAccount implements IStatusMessageOfAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: Account | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? Account.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfAccount {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: Account | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfListOfCategoryCommonModel implements IStatusMessageOfListOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfCategoryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryCommonModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfCategoryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfCategoryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel[] | undefined;
    currentID?: string | undefined;
}

export class CategoryCommonModel implements ICategoryCommonModel {
    id?: string | undefined;
    group_id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    description?: string | undefined;
    company_code?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    items?: CategoryCommonModel[] | undefined;

    constructor(data?: ICategoryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.group_id = _data["group_id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.name1 = _data["name1"];
            this.name2 = _data["name2"];
            this.name3 = _data["name3"];
            this.number_order = _data["number_order"];
            this.description = _data["description"];
            this.company_code = _data["company_code"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryCommonModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["group_id"] = this.group_id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["name1"] = this.name1;
        data["name2"] = this.name2;
        data["name3"] = this.name3;
        data["number_order"] = this.number_order;
        data["description"] = this.description;
        data["company_code"] = this.company_code;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryCommonModel {
    id?: string | undefined;
    group_id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    description?: string | undefined;
    company_code?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    items?: CategoryCommonModel[] | undefined;
}

export class StatusMessageOfCategoryCommonModel implements IStatusMessageOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfCategoryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? CategoryCommonModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfCategoryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfCategoryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfNational implements IStatusMessageOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfNational) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? National.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfNational {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfNational();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National | undefined;
    currentID?: string | undefined;
}

export class National implements INational {
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    language?: string | undefined;
    zip_code?: string | undefined;
    active?: boolean | undefined;

    constructor(data?: INational) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.language = _data["language"];
            this.zip_code = _data["zip_code"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): National {
        data = typeof data === 'object' ? data : {};
        let result = new National();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["language"] = this.language;
        data["zip_code"] = this.zip_code;
        data["active"] = this.active;
        return data;
    }
}

export interface INational {
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    language?: string | undefined;
    zip_code?: string | undefined;
    active?: boolean | undefined;
}

export class StatusMessageOfListOfNational implements IStatusMessageOfListOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfNational) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(National.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfNational {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfNational();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysPermission implements IStatusMessageOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysPermission.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission | undefined;
    currentID?: string | undefined;
}

export class SysPermission implements ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: number | undefined;
    codeCompany?: string | undefined;

    constructor(data?: ISysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.order_number = _data["order_number"];
            this.codeCompany = _data["codeCompany"];
        }
    }

    static fromJS(data: any): SysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new SysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["order_number"] = this.order_number;
        data["codeCompany"] = this.codeCompany;
        return data;
    }
}

export interface ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: number | undefined;
    codeCompany?: string | undefined;
}

export class StatusMessageOfListOfSysPermission implements IStatusMessageOfListOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysPermission.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysStatus implements IStatusMessageOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysStatus.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus | undefined;
    currentID?: string | undefined;
}

export class SysStatus implements ISysStatus {
    id?: string | undefined;
    module?: string | undefined;
    appModule?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    order_numer?: number | undefined;
    enable?: boolean | undefined;
    accept_login?: boolean | undefined;

    constructor(data?: ISysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.module = _data["module"];
            this.appModule = _data["appModule"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.order_numer = _data["order_numer"];
            this.enable = _data["enable"];
            this.accept_login = _data["accept_login"];
        }
    }

    static fromJS(data: any): SysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["module"] = this.module;
        data["appModule"] = this.appModule;
        data["code"] = this.code;
        data["name"] = this.name;
        data["order_numer"] = this.order_numer;
        data["enable"] = this.enable;
        data["accept_login"] = this.accept_login;
        return data;
    }
}

export interface ISysStatus {
    id?: string | undefined;
    module?: string | undefined;
    appModule?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    order_numer?: number | undefined;
    enable?: boolean | undefined;
    accept_login?: boolean | undefined;
}

export class StatusMessageOfListOfSysStatus implements IStatusMessageOfListOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysStatus.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysTypeAccount implements IStatusMessageOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysTypeAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysTypeAccount.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysTypeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysTypeAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount | undefined;
    currentID?: string | undefined;
}

export class SysTypeAccount implements ISysTypeAccount {
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: ISysTypeAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SysTypeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new SysTypeAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface ISysTypeAccount {
    code?: string | undefined;
    name?: string | undefined;
}

export class StatusMessageOfListOfSysTypeAccount implements IStatusMessageOfListOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysTypeAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysTypeAccount.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysTypeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysTypeAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount[] | undefined;
    currentID?: string | undefined;
}

export class Sys_Menu_Tree_View_MODEL extends SysMenu implements ISys_Menu_Tree_View_MODEL {
    items?: Sys_Menu_Tree_View_MODEL[] | undefined;
    expanded?: boolean | undefined;
    selected?: boolean | undefined;
    account?: string | undefined;

    constructor(data?: ISys_Menu_Tree_View_MODEL) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            this.expanded = _data["expanded"];
            this.selected = _data["selected"];
            this.account = _data["account"];
        }
    }

    static override fromJS(data: any): Sys_Menu_Tree_View_MODEL {
        data = typeof data === 'object' ? data : {};
        let result = new Sys_Menu_Tree_View_MODEL();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["expanded"] = this.expanded;
        data["selected"] = this.selected;
        data["account"] = this.account;
        super.toJSON(data);
        return data;
    }
}

export interface ISys_Menu_Tree_View_MODEL extends ISysMenu {
    items?: Sys_Menu_Tree_View_MODEL[] | undefined;
    expanded?: boolean | undefined;
    selected?: boolean | undefined;
    account?: string | undefined;
}

export class StatusMessageOfMenuPermissionInsModel implements IStatusMessageOfMenuPermissionInsModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MenuPermissionInsModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfMenuPermissionInsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? MenuPermissionInsModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfMenuPermissionInsModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfMenuPermissionInsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfMenuPermissionInsModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: MenuPermissionInsModel | undefined;
    currentID?: string | undefined;
}

export class MenuPermissionInsModel implements IMenuPermissionInsModel {
    account?: Account | undefined;
    list_permission?: MenuPermissions[] | undefined;
    list_menu?: SysMenu[] | undefined;

    constructor(data?: IMenuPermissionInsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            if (Array.isArray(_data["list_permission"])) {
                this.list_permission = [] as any;
                for (let item of _data["list_permission"])
                    this.list_permission!.push(MenuPermissions.fromJS(item));
            }
            if (Array.isArray(_data["list_menu"])) {
                this.list_menu = [] as any;
                for (let item of _data["list_menu"])
                    this.list_menu!.push(SysMenu.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuPermissionInsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MenuPermissionInsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        if (Array.isArray(this.list_permission)) {
            data["list_permission"] = [];
            for (let item of this.list_permission)
                data["list_permission"].push(item.toJSON());
        }
        if (Array.isArray(this.list_menu)) {
            data["list_menu"] = [];
            for (let item of this.list_menu)
                data["list_menu"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuPermissionInsModel {
    account?: Account | undefined;
    list_permission?: MenuPermissions[] | undefined;
    list_menu?: SysMenu[] | undefined;
}

export class MenuPermissions implements IMenuPermissions {
    id?: string | undefined;
    account?: string | undefined;
    menuid?: string | undefined;
    notes?: string | undefined;
    companyCode?: string | undefined;

    constructor(data?: IMenuPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.account = _data["account"];
            this.menuid = _data["menuid"];
            this.notes = _data["notes"];
            this.companyCode = _data["companyCode"];
        }
    }

    static fromJS(data: any): MenuPermissions {
        data = typeof data === 'object' ? data : {};
        let result = new MenuPermissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["account"] = this.account;
        data["menuid"] = this.menuid;
        data["notes"] = this.notes;
        data["companyCode"] = this.companyCode;
        return data;
    }
}

export interface IMenuPermissions {
    id?: string | undefined;
    account?: string | undefined;
    menuid?: string | undefined;
    notes?: string | undefined;
    companyCode?: string | undefined;
}

export class StatusMessageOfListOfString implements IStatusMessageOfListOfString {
    status?: number | undefined;
    msg?: string | undefined;
    data?: string[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfString {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfString {
    status?: number | undefined;
    msg?: string | undefined;
    data?: string[] | undefined;
    currentID?: string | undefined;
}

export class UserInformationClientGetUser implements IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[] | undefined;

    constructor(data?: IUserInformationClientGetUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
            this.nameCompany = _data["nameCompany"];
            this.email = _data["email"];
            this.nameDepartment = _data["nameDepartment"];
            this.nameBrach = _data["nameBrach"];
            this.codeDepartment = _data["codeDepartment"];
            this.codeName = _data["codeName"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(TOKEN.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInformationClientGetUser {
        data = typeof data === 'object' ? data : {};
        let result = new UserInformationClientGetUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        data["nameCompany"] = this.nameCompany;
        data["email"] = this.email;
        data["nameDepartment"] = this.nameDepartment;
        data["nameBrach"] = this.nameBrach;
        data["codeDepartment"] = this.codeDepartment;
        data["codeName"] = this.codeName;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[] | undefined;
}

export class Company implements ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.adminCompany = _data["adminCompany"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["adminCompany"] = this.adminCompany;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;
}

export class QueryCommonModel implements IQueryCommonModel {
    table_name?: string | undefined;
    action?: string | undefined;
    string_query?: string | undefined;

    constructor(data?: IQueryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.table_name = _data["table_name"];
            this.action = _data["action"];
            this.string_query = _data["string_query"];
        }
    }

    static fromJS(data: any): QueryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new QueryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["table_name"] = this.table_name;
        data["action"] = this.action;
        data["string_query"] = this.string_query;
        return data;
    }
}

export interface IQueryCommonModel {
    table_name?: string | undefined;
    action?: string | undefined;
    string_query?: string | undefined;
}

export class StatusMessageOfString implements IStatusMessageOfString {
    status?: number | undefined;
    msg?: string | undefined;
    data?: string | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"];
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfString {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfString {
    status?: number | undefined;
    msg?: string | undefined;
    data?: string | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfListOfUploadFileModel implements IStatusMessageOfListOfUploadFileModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: UploadFileModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfUploadFileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UploadFileModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfUploadFileModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfUploadFileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfUploadFileModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: UploadFileModel[] | undefined;
    currentID?: string | undefined;
}

export class UploadFileModel implements IUploadFileModel {
    table_name?: string | undefined;
    col_name?: string | undefined;
    create_date?: Date | undefined;
    create_by?: string | undefined;
    id?: string | undefined;
    file_name?: string | undefined;
    file_type?: string | undefined;
    file_size?: number | undefined;
    file_path?: string | undefined;
    description?: string | undefined;
    company_code?: string | undefined;
    enabled?: boolean | undefined;
    files?: string[] | undefined;
    file?: any | undefined;
    file2?: string | undefined;

    constructor(data?: IUploadFileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.table_name = _data["table_name"];
            this.col_name = _data["col_name"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.id = _data["id"];
            this.file_name = _data["file_name"];
            this.file_type = _data["file_type"];
            this.file_size = _data["file_size"];
            this.file_path = _data["file_path"];
            this.description = _data["description"];
            this.company_code = _data["company_code"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(item);
            }
            this.file = _data["file"];
            this.file2 = _data["file2"];
        }
    }

    static fromJS(data: any): UploadFileModel {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["table_name"] = this.table_name;
        data["col_name"] = this.col_name;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["id"] = this.id;
        data["file_name"] = this.file_name;
        data["file_type"] = this.file_type;
        data["file_size"] = this.file_size;
        data["file_path"] = this.file_path;
        data["description"] = this.description;
        data["company_code"] = this.company_code;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item);
        }
        data["file"] = this.file;
        data["file2"] = this.file2;
        return data;
    }
}

export interface IUploadFileModel {
    table_name?: string | undefined;
    col_name?: string | undefined;
    create_date?: Date | undefined;
    create_by?: string | undefined;
    id?: string | undefined;
    file_name?: string | undefined;
    file_type?: string | undefined;
    file_size?: number | undefined;
    file_path?: string | undefined;
    description?: string | undefined;
    company_code?: string | undefined;
    enabled?: boolean | undefined;
    files?: string[] | undefined;
    file?: any | undefined;
    file2?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}