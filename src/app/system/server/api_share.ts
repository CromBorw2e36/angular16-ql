import { APIBase } from './APIBase';
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import LayoutComponentBase from 'src/app/share/layoutBase/LayoutComponentBase';
import { Injector } from '@angular/core';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ISysActionClient {
    sysActionIns(action: SysAction): Observable<StatusMessageOfSysAction>;
    sysActionUpd(action: SysAction): Observable<StatusMessageOfObject>;
    sysActionDel(action: SysAction): Observable<StatusMessageOfObject>;
    sysActionGetByCode(code?: string | undefined): Observable<SysAction>;
    sysActionGetByCodeByPermision(actionCode?: string | undefined): Observable<SysAction[]>;
    sysDropDownActionIns(dropdownAction: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction>;
    sysDropdownActionUpd(action: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction>;
    sysDropdownActionDel(action: SysDropDownAction): Observable<StatusMessageOfObject>;
    sysDropActionGetListSysActionByCode(dropdownAction: SysDropDownAction): Observable<SysAction[]>;
    sysDropdownActionGet(actionCode: SysDropDownAction): Observable<SysDropDownAction>;
    getListActionByGroupCode(groupAction: SysGroupAction): Observable<StatusMessageOfListOfSysAction>;
}

@Injectable()
export class SysActionClient extends APIBase implements ISysActionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    sysActionIns(action: SysAction): Observable<StatusMessageOfSysAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysAction>;
        }));
    }

    protected processSysActionIns(response: HttpResponseBase): Observable<StatusMessageOfSysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionUpd(action: SysAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionUpd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionUpd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionUpd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysActionUpd(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionDel(action: SysAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionDel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysActionDel(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionGetByCode(code?: string | undefined): Observable<SysAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionGetByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionGetByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction>;
        }));
    }

    protected processSysActionGetByCode(response: HttpResponseBase): Observable<SysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionGetByCodeByPermision(actionCode?: string | undefined): Observable<SysAction[]> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionGetByCode2?";
        if (actionCode === null)
            throw new Error("The parameter 'actionCode' cannot be null.");
        else if (actionCode !== undefined)
            url_ += "actionCode=" + encodeURIComponent("" + actionCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionGetByCodeByPermision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionGetByCodeByPermision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction[]>;
        }));
    }

    protected processSysActionGetByCodeByPermision(response: HttpResponseBase): Observable<SysAction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropDownActionIns(dropdownAction: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropDownActionIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dropdownAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropDownActionIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropDownActionIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysDropDownAction>;
        }));
    }

    protected processSysDropDownActionIns(response: HttpResponseBase): Observable<StatusMessageOfSysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionUpd(action: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropdownActionUpd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionUpd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionUpd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysDropDownAction>;
        }));
    }

    protected processSysDropdownActionUpd(response: HttpResponseBase): Observable<StatusMessageOfSysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionDel(action: SysDropDownAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropdownActionDel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysDropdownActionDel(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropActionGetListSysActionByCode(dropdownAction: SysDropDownAction): Observable<SysAction[]> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropActionGetListSysActionByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dropdownAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropActionGetListSysActionByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropActionGetListSysActionByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction[]>;
        }));
    }

    protected processSysDropActionGetListSysActionByCode(response: HttpResponseBase): Observable<SysAction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionGet(actionCode: SysDropDownAction): Observable<SysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropActionGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionCode);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysDropDownAction>;
        }));
    }

    protected processSysDropdownActionGet(response: HttpResponseBase): Observable<SysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListActionByGroupCode(groupAction: SysGroupAction): Observable<StatusMessageOfListOfSysAction> {
        let url_ = this.baseUrl + "/api/sysAction/GetListActionByGroupCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListActionByGroupCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListActionByGroupCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysAction>;
        }));
    }

    protected processGetListActionByGroupCode(response: HttpResponseBase): Observable<StatusMessageOfListOfSysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysGenRowTablesClient {
    genRowTableInsert(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableUpdate(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableDelete(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableSearch(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfListOfSysGenRowTable>;
}

@Injectable()
export class SysGenRowTablesClient extends APIBase implements ISysGenRowTablesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    genRowTableInsert(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableInsert(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableUpdate(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableDelete(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableDelete(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableSearch(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfListOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysMenusClient {
    sysMenuSearch(model: SysMenu): Observable<StatusMessageOfListOfSysMenu>;
    sysMenuInsert(model: SysMenu): Observable<StatusMessageOfSysMenu>;
    sysMenuUpdate(model: SysMenu): Observable<StatusMessageOfSysMenu>;
    sysMenuDelete(model: SysMenu): Observable<StatusMessageOfObject>;
}

@Injectable()
export class SysMenusClient extends APIBase implements ISysMenusClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    sysMenuSearch(model: SysMenu): Observable<StatusMessageOfListOfSysMenu> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysMenu>;
        }));
    }

    protected processSysMenuSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysMenuInsert(model: SysMenu): Observable<StatusMessageOfSysMenu> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysMenu>;
        }));
    }

    protected processSysMenuInsert(response: HttpResponseBase): Observable<StatusMessageOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysMenuUpdate(model: SysMenu): Observable<StatusMessageOfSysMenu> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysMenu>;
        }));
    }

    protected processSysMenuUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysMenuDelete(model: SysMenu): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/SysMenus/SysMenuDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysMenuDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysMenuDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysMenuDelete(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysVoucherFormClient {
    voucherFormColumnInsert(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnUpdate(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnDelete(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnSearch(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfListOfSysVoucherFormColumn>;
    voucherFormGroupInsert(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupUpdate(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupDelete(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupSearch(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfListOfSysVoucherFormGroup>;
}

@Injectable()
export class SysVoucherFormClient extends APIBase implements ISysVoucherFormClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    voucherFormColumnInsert(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnInsert(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnUpdate(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnDelete(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnDelete(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnSearch(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfListOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupInsert(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupInsert(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupUpdate(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupDelete(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupDelete(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupSearch(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfListOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICurrentJobPositionsClient {
    getCurrentJobPositions(): Observable<CurrentJobPosition[]>;
    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition>;
    getCurrentJobPosition(id: string): Observable<CurrentJobPosition>;
    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse>;
    deleteCurrentJobPosition(id: string): Observable<FileResponse>;
}

@Injectable()
export class CurrentJobPositionsClient extends APIBase implements ICurrentJobPositionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getCurrentJobPositions(): Observable<CurrentJobPosition[]> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition[]>;
        }));
    }

    protected processGetCurrentJobPositions(response: HttpResponseBase): Observable<CurrentJobPosition[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrentJobPosition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processPostCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrentJobPosition(id: string): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processGetCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCurrentJobPosition(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISalaryAndBenefitsClient {
    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]>;
    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits>;
    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits>;
    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse>;
    deleteSalaryAndBenefits(id: string): Observable<FileResponse>;
}

@Injectable()
export class SalaryAndBenefitsClient extends APIBase implements ISalaryAndBenefitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefitsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefitsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits[]>;
        }));
    }

    protected processGetSalaryAndBenefitsAll(response: HttpResponseBase): Observable<SalaryAndBenefits[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalaryAndBenefits.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processPostSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processGetSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSalaryAndBenefits(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWorkHistoriesClient {
    getWorkHistories(): Observable<WorkHistory[]>;
    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory>;
    getWorkHistory(id: string): Observable<WorkHistory>;
    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse>;
    deleteWorkHistory(id: string): Observable<FileResponse>;
}

@Injectable()
export class WorkHistoriesClient extends APIBase implements IWorkHistoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getWorkHistories(): Observable<WorkHistory[]> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory[]>;
        }));
    }

    protected processGetWorkHistories(response: HttpResponseBase): Observable<WorkHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processPostWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWorkHistory(id: string): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processGetWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWorkHistory(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAccountsClient {
    checkTheExpirationDateOfToken(): Observable<boolean>;
    login(account: AccountClientLoginParamsModel): Observable<StatusMessageOfObject>;
    accountIns(profile: AccountClientProfileModel): Observable<StatusMessageOfObject>;
    updateAccount(account: Account): Observable<StatusMessageOfObject>;
    deleteAccount(id: string): Observable<StatusMessageOfObject>;
}

@Injectable()
export class AccountsClient extends APIBase implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    checkTheExpirationDateOfToken(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Accounts/CheckTheExpirationDateOfToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckTheExpirationDateOfToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTheExpirationDateOfToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckTheExpirationDateOfToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(account: AccountClientLoginParamsModel): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountIns(profile: AccountClientProfileModel): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/AccountIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processAccountIns(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAccount(account: Account): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/UpdateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAccount(id: string): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICategoryCommonClient {
    categoryCommonSearch(model: CategoryCommonModel): Observable<StatusMessageOfListOfCategoryCommonModel>;
    categoryCommonInsert(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel>;
    categoryCommonUpdate(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel>;
    categoryCommonDelete(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel>;
    nationalLanguageInsert(model: National): Observable<StatusMessageOfNational>;
    nationalLanguageUpdate(model: National): Observable<StatusMessageOfNational>;
    nationalLanguageDelete(model: National): Observable<StatusMessageOfNational>;
    nationalLanguageSearch(model: National): Observable<StatusMessageOfListOfNational>;
    sysPermissionInsert(model: SysPermission): Observable<StatusMessageOfSysPermission>;
    sysPermissionUpdate(model: SysPermission): Observable<StatusMessageOfSysPermission>;
    sysPermissionDelete(model: SysPermission): Observable<StatusMessageOfSysPermission>;
    sysPermissionSearch(model: SysPermission): Observable<StatusMessageOfListOfSysPermission>;
    sysStatusInsert(model: SysStatus): Observable<StatusMessageOfSysStatus>;
    sysStatusUpdate(model: SysStatus): Observable<StatusMessageOfSysStatus>;
    sysStatusDelete(model: SysStatus): Observable<StatusMessageOfSysStatus>;
    sysStatusSearch(model: SysStatus): Observable<StatusMessageOfListOfSysStatus>;
    sysTypeAccountInsert(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount>;
    sysTypeAccountUpdate(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount>;
    sysTypeAccountDelete(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount>;
    sysTypeAccountSearch(model: SysTypeAccount): Observable<StatusMessageOfListOfSysTypeAccount>;
    testDynamicData(model: any): Observable<FileResponse>;
}

@Injectable()
export class CategoryCommonClient extends APIBase implements ICategoryCommonClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    categoryCommonSearch(model: CategoryCommonModel): Observable<StatusMessageOfListOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    categoryCommonInsert(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonInsert(response: HttpResponseBase): Observable<StatusMessageOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    categoryCommonUpdate(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonUpdate(response: HttpResponseBase): Observable<StatusMessageOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    categoryCommonDelete(model: CategoryCommonModel): Observable<StatusMessageOfCategoryCommonModel> {
        let url_ = this.baseUrl + "/api/CategoryCommon/CategoryCommonDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCategoryCommonDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryCommonDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfCategoryCommonModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfCategoryCommonModel>;
        }));
    }

    protected processCategoryCommonDelete(response: HttpResponseBase): Observable<StatusMessageOfCategoryCommonModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfCategoryCommonModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageInsert(model: National): Observable<StatusMessageOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfNational>;
        }));
    }

    protected processNationalLanguageInsert(response: HttpResponseBase): Observable<StatusMessageOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageUpdate(model: National): Observable<StatusMessageOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfNational>;
        }));
    }

    protected processNationalLanguageUpdate(response: HttpResponseBase): Observable<StatusMessageOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageDelete(model: National): Observable<StatusMessageOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfNational>;
        }));
    }

    protected processNationalLanguageDelete(response: HttpResponseBase): Observable<StatusMessageOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    nationalLanguageSearch(model: National): Observable<StatusMessageOfListOfNational> {
        let url_ = this.baseUrl + "/api/CategoryCommon/NationalLanguageSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processNationalLanguageSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNationalLanguageSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfNational>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfNational>;
        }));
    }

    protected processNationalLanguageSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfNational> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfNational.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionInsert(model: SysPermission): Observable<StatusMessageOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysPermission>;
        }));
    }

    protected processSysPermissionInsert(response: HttpResponseBase): Observable<StatusMessageOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionUpdate(model: SysPermission): Observable<StatusMessageOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysPermission>;
        }));
    }

    protected processSysPermissionUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionDelete(model: SysPermission): Observable<StatusMessageOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysPermission>;
        }));
    }

    protected processSysPermissionDelete(response: HttpResponseBase): Observable<StatusMessageOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysPermissionSearch(model: SysPermission): Observable<StatusMessageOfListOfSysPermission> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysPermissionSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysPermissionSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysPermissionSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysPermission>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysPermission>;
        }));
    }

    protected processSysPermissionSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysPermission> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysPermission.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusInsert(model: SysStatus): Observable<StatusMessageOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysStatus>;
        }));
    }

    protected processSysStatusInsert(response: HttpResponseBase): Observable<StatusMessageOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusUpdate(model: SysStatus): Observable<StatusMessageOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysStatus>;
        }));
    }

    protected processSysStatusUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusDelete(model: SysStatus): Observable<StatusMessageOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysStatus>;
        }));
    }

    protected processSysStatusDelete(response: HttpResponseBase): Observable<StatusMessageOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysStatusSearch(model: SysStatus): Observable<StatusMessageOfListOfSysStatus> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysStatusSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysStatusSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysStatusSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysStatus>;
        }));
    }

    protected processSysStatusSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountInsert(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountInsert(response: HttpResponseBase): Observable<StatusMessageOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountUpdate(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountDelete(model: SysTypeAccount): Observable<StatusMessageOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountDelete(response: HttpResponseBase): Observable<StatusMessageOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysTypeAccountSearch(model: SysTypeAccount): Observable<StatusMessageOfListOfSysTypeAccount> {
        let url_ = this.baseUrl + "/api/CategoryCommon/SysTypeAccountSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysTypeAccountSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysTypeAccountSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysTypeAccount>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysTypeAccount>;
        }));
    }

    protected processSysTypeAccountSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysTypeAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysTypeAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    testDynamicData(model: any): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CategoryCommon/TestDynamicData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestDynamicData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestDynamicData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processTestDynamicData(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMenuPermissionsClient {
    getListMenu(): Observable<SysMenu[]>;
    getListMenuV2(): Observable<SysMenu[]>;
    listMenuTreeView(): Observable<Sys_Menu_Tree_View_MODEL[]>;
    listMenuById(p: Sys_Menu_Tree_View_MODEL): Observable<Sys_Menu_Tree_View_MODEL[]>;
    getAllListMenu(): Observable<SysMenu>;
}

@Injectable()
export class MenuPermissionsClient extends APIBase implements IMenuPermissionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getListMenu(): Observable<SysMenu[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu[]>;
        }));
    }

    protected processGetListMenu(response: HttpResponseBase): Observable<SysMenu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysMenu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListMenuV2(): Observable<SysMenu[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/sys_menu_get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListMenuV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMenuV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu[]>;
        }));
    }

    protected processGetListMenuV2(response: HttpResponseBase): Observable<SysMenu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysMenu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listMenuTreeView(): Observable<Sys_Menu_Tree_View_MODEL[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_tree_view";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListMenuTreeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMenuTreeView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
        }));
    }

    protected processListMenuTreeView(response: HttpResponseBase): Observable<Sys_Menu_Tree_View_MODEL[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listMenuById(p: Sys_Menu_Tree_View_MODEL): Observable<Sys_Menu_Tree_View_MODEL[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_by_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(p);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListMenuById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMenuById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
        }));
    }

    protected processListMenuById(response: HttpResponseBase): Observable<Sys_Menu_Tree_View_MODEL[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllListMenu(): Observable<SysMenu> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_get_all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllListMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllListMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu>;
        }));
    }

    protected processGetAllListMenu(response: HttpResponseBase): Observable<SysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserInfoesClient {
    userIns(userInfo: UserInfo): Observable<StatusMessageOfObject>;
    updUser(userInfo: UserInfo): Observable<StatusMessageOfObject>;
    getMyUser(): Observable<UserInfo>;
    getLstUser(): Observable<UserInfo[]>;
    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser>;
    deleteUserInfo(id: string): Observable<FileResponse>;
}

@Injectable()
export class UserInfoesClient extends APIBase implements IUserInfoesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    userIns(userInfo: UserInfo): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/UserInfoes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUserIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUserIns(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updUser(userInfo: UserInfo): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/UserInfoes/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUpdUser(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyUser(): Observable<UserInfo> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMyUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo>;
        }));
    }

    protected processGetMyUser(response: HttpResponseBase): Observable<UserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLstUser(): Observable<UserInfo[]> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLstUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLstUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo[]>;
        }));
    }

    protected processGetLstUser(response: HttpResponseBase): Observable<UserInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUserInformation?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInformationClientGetUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInformationClientGetUser>;
        }));
    }

    protected processGetUserInformation(response: HttpResponseBase): Observable<UserInformationClientGetUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInformationClientGetUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUserInfo(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserInfoes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteUserInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICommonContronllerClient {
    listCompany(): Observable<Company[]>;
    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]>;
    getPermissionByCompany(): Observable<SysPermission[]>;
    excuteQueryString(model: QueryCommonModel): Observable<any[]>;
}

@Injectable()
export class CommonContronllerClient extends APIBase implements ICommonContronllerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    listCompany(): Observable<Company[]> {
        let url_ = this.baseUrl + "/api/CommonContronller";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Company[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Company[]>;
        }));
    }

    protected processListCompany(response: HttpResponseBase): Observable<Company[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Company.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListStatusByModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pSysStatus);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatusByModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysStatus[]>;
        }));
    }

    protected processGetStatusByModule(response: HttpResponseBase): Observable<SysStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPermissionByCompany(): Observable<SysPermission[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListPermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionByCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionByCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysPermission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysPermission[]>;
        }));
    }

    protected processGetPermissionByCompany(response: HttpResponseBase): Observable<SysPermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysPermission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    excuteQueryString(model: QueryCommonModel): Observable<any[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ExcuteQueryString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExcuteQueryString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcuteQueryString(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processExcuteQueryString(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class StatusMessageOfSysAction implements IStatusMessageOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysAction.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction | undefined;
    currentID?: string | undefined;
}

export class SysAction implements ISysAction {
    code?: string | undefined;
    nameVn?: string | undefined;
    nameOther?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    isDisable?: boolean | undefined;
    description?: string | undefined;
    url_1?: string | undefined;
    url_2?: string | undefined;
    url_3?: string | undefined;
    url_4?: string | undefined;
    isClocked?: boolean | undefined;
    codeGroup?: string | undefined;
    orderNo?: number | undefined;

    constructor(data?: ISysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.nameVn = _data["nameVn"];
            this.nameOther = _data["nameOther"];
            this.icon = _data["icon"];
            this.color = _data["color"];
            this.backgroundColor = _data["backgroundColor"];
            this.isDisable = _data["isDisable"];
            this.description = _data["description"];
            this.url_1 = _data["url_1"];
            this.url_2 = _data["url_2"];
            this.url_3 = _data["url_3"];
            this.url_4 = _data["url_4"];
            this.isClocked = _data["isClocked"];
            this.codeGroup = _data["codeGroup"];
            this.orderNo = _data["orderNo"];
        }
    }

    static fromJS(data: any): SysAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["nameVn"] = this.nameVn;
        data["nameOther"] = this.nameOther;
        data["icon"] = this.icon;
        data["color"] = this.color;
        data["backgroundColor"] = this.backgroundColor;
        data["isDisable"] = this.isDisable;
        data["description"] = this.description;
        data["url_1"] = this.url_1;
        data["url_2"] = this.url_2;
        data["url_3"] = this.url_3;
        data["url_4"] = this.url_4;
        data["isClocked"] = this.isClocked;
        data["codeGroup"] = this.codeGroup;
        data["orderNo"] = this.orderNo;
        return data;
    }
}

export interface ISysAction {
    code?: string | undefined;
    nameVn?: string | undefined;
    nameOther?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    isDisable?: boolean | undefined;
    description?: string | undefined;
    url_1?: string | undefined;
    url_2?: string | undefined;
    url_3?: string | undefined;
    url_4?: string | undefined;
    isClocked?: boolean | undefined;
    codeGroup?: string | undefined;
    orderNo?: number | undefined;
}

export class StatusMessageOfObject implements IStatusMessageOfObject {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"];
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfObject {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfObject {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysDropDownAction implements IStatusMessageOfSysDropDownAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysDropDownAction | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysDropDownAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysDropDownAction.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysDropDownAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysDropDownAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysDropDownAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysDropDownAction | undefined;
    currentID?: string | undefined;
}

export class SysDropDownAction implements ISysDropDownAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;

    constructor(data?: ISysDropDownAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.codeAction = _data["codeAction"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
            this.isClocked = _data["isClocked"];
        }
    }

    static fromJS(data: any): SysDropDownAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysDropDownAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["codeAction"] = this.codeAction;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        data["isClocked"] = this.isClocked;
        return data;
    }
}

export interface ISysDropDownAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
}

export class StatusMessageOfListOfSysAction implements IStatusMessageOfListOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysAction.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction[] | undefined;
    currentID?: string | undefined;
}

export class SysGroupAction implements ISysGroupAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
    isDropDown?: boolean | undefined;
    listChildAction?: SysAction[] | undefined;

    constructor(data?: ISysGroupAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.codeAction = _data["codeAction"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
            this.isClocked = _data["isClocked"];
            this.isDropDown = _data["isDropDown"];
            if (Array.isArray(_data["listChildAction"])) {
                this.listChildAction = [] as any;
                for (let item of _data["listChildAction"])
                    this.listChildAction!.push(SysAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SysGroupAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysGroupAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["codeAction"] = this.codeAction;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        data["isClocked"] = this.isClocked;
        data["isDropDown"] = this.isDropDown;
        if (Array.isArray(this.listChildAction)) {
            data["listChildAction"] = [];
            for (let item of this.listChildAction)
                data["listChildAction"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISysGroupAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
    isDropDown?: boolean | undefined;
    listChildAction?: SysAction[] | undefined;
}

export class StatusMessageOfSysGenRowTable implements IStatusMessageOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysGenRowTable.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable | undefined;
    currentID?: string | undefined;
}

export class SysGenRowTable implements ISysGenRowTable {
    id?: string | undefined;
    table_name?: string | undefined;
    dataField?: string | undefined;
    caption?: string | undefined;
    caption_VN?: string | undefined;
    name?: string | undefined;
    dataType?: string | undefined;
    format?: string | undefined;
    width?: number | undefined;
    visible?: boolean | undefined;
    minWidth?: number | undefined;
    alignment?: string | undefined;
    allowEditing?: boolean | undefined;
    allowFiltering?: boolean | undefined;
    allowFixing?: boolean | undefined;
    allowGrouping?: boolean | undefined;
    allowHeaderFiltering?: boolean | undefined;
    allowHiding?: boolean | undefined;
    allowSearch?: boolean | undefined;
    allowSorting?: boolean | undefined;
    autoExpandGroup?: boolean | undefined;
    columns?: SysGenRowTable[] | undefined;
    column_child?: string | undefined;
    cssClass?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;

    constructor(data?: ISysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.dataField = _data["dataField"];
            this.caption = _data["caption"];
            this.caption_VN = _data["caption_VN"];
            this.name = _data["name"];
            this.dataType = _data["dataType"];
            this.format = _data["format"];
            this.width = _data["width"];
            this.visible = _data["visible"];
            this.minWidth = _data["minWidth"];
            this.alignment = _data["alignment"];
            this.allowEditing = _data["allowEditing"];
            this.allowFiltering = _data["allowFiltering"];
            this.allowFixing = _data["allowFixing"];
            this.allowGrouping = _data["allowGrouping"];
            this.allowHeaderFiltering = _data["allowHeaderFiltering"];
            this.allowHiding = _data["allowHiding"];
            this.allowSearch = _data["allowSearch"];
            this.allowSorting = _data["allowSorting"];
            this.autoExpandGroup = _data["autoExpandGroup"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(SysGenRowTable.fromJS(item));
            }
            this.column_child = _data["column_child"];
            this.cssClass = _data["cssClass"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.companyCode = _data["companyCode"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new SysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["dataField"] = this.dataField;
        data["caption"] = this.caption;
        data["caption_VN"] = this.caption_VN;
        data["name"] = this.name;
        data["dataType"] = this.dataType;
        data["format"] = this.format;
        data["width"] = this.width;
        data["visible"] = this.visible;
        data["minWidth"] = this.minWidth;
        data["alignment"] = this.alignment;
        data["allowEditing"] = this.allowEditing;
        data["allowFiltering"] = this.allowFiltering;
        data["allowFixing"] = this.allowFixing;
        data["allowGrouping"] = this.allowGrouping;
        data["allowHeaderFiltering"] = this.allowHeaderFiltering;
        data["allowHiding"] = this.allowHiding;
        data["allowSearch"] = this.allowSearch;
        data["allowSorting"] = this.allowSorting;
        data["autoExpandGroup"] = this.autoExpandGroup;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["column_child"] = this.column_child;
        data["cssClass"] = this.cssClass;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["companyCode"] = this.companyCode;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        return data;
    }
}

export interface ISysGenRowTable {
    id?: string | undefined;
    table_name?: string | undefined;
    dataField?: string | undefined;
    caption?: string | undefined;
    caption_VN?: string | undefined;
    name?: string | undefined;
    dataType?: string | undefined;
    format?: string | undefined;
    width?: number | undefined;
    visible?: boolean | undefined;
    minWidth?: number | undefined;
    alignment?: string | undefined;
    allowEditing?: boolean | undefined;
    allowFiltering?: boolean | undefined;
    allowFixing?: boolean | undefined;
    allowGrouping?: boolean | undefined;
    allowHeaderFiltering?: boolean | undefined;
    allowHiding?: boolean | undefined;
    allowSearch?: boolean | undefined;
    allowSorting?: boolean | undefined;
    autoExpandGroup?: boolean | undefined;
    columns?: SysGenRowTable[] | undefined;
    column_child?: string | undefined;
    cssClass?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
}

export class StatusMessageOfListOfSysGenRowTable implements IStatusMessageOfListOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysGenRowTable.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfListOfSysMenu implements IStatusMessageOfListOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysMenu.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu[] | undefined;
    currentID?: string | undefined;
}

export class SysMenu implements ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    nameVN?: string | undefined;
    icon?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;
    action1?: string | undefined;
    action2?: string | undefined;
    action3?: string | undefined;
    action4?: string | undefined;
    action5?: string | undefined;
    action6?: string | undefined;
    action7?: string | undefined;

    constructor(data?: ISysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuid = _data["menuid"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.nameVN = _data["nameVN"];
            this.icon = _data["icon"];
            this.active = _data["active"];
            this.isParent = _data["isParent"];
            this.menuIDParent = _data["menuIDParent"];
            this.defaultActive = _data["defaultActive"];
            this.moduleApp = _data["moduleApp"];
            this.action1 = _data["action1"];
            this.action2 = _data["action2"];
            this.action3 = _data["action3"];
            this.action4 = _data["action4"];
            this.action5 = _data["action5"];
            this.action6 = _data["action6"];
            this.action7 = _data["action7"];
        }
    }

    static fromJS(data: any): SysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new SysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuid"] = this.menuid;
        data["url"] = this.url;
        data["name"] = this.name;
        data["nameVN"] = this.nameVN;
        data["icon"] = this.icon;
        data["active"] = this.active;
        data["isParent"] = this.isParent;
        data["menuIDParent"] = this.menuIDParent;
        data["defaultActive"] = this.defaultActive;
        data["moduleApp"] = this.moduleApp;
        data["action1"] = this.action1;
        data["action2"] = this.action2;
        data["action3"] = this.action3;
        data["action4"] = this.action4;
        data["action5"] = this.action5;
        data["action6"] = this.action6;
        data["action7"] = this.action7;
        return data;
    }
}

export interface ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    nameVN?: string | undefined;
    icon?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;
    action1?: string | undefined;
    action2?: string | undefined;
    action3?: string | undefined;
    action4?: string | undefined;
    action5?: string | undefined;
    action6?: string | undefined;
    action7?: string | undefined;
}

export class StatusMessageOfSysMenu implements IStatusMessageOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysMenu.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysMenu {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysMenu | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysVoucherFormColumn implements IStatusMessageOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysVoucherFormColumn.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn | undefined;
    currentID?: string | undefined;
}

export class SysVoucherFormColumn implements ISysVoucherFormColumn {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    labelModel?: string | undefined;
    edit?: boolean | undefined;
    labelControl?: string | undefined;
    labelControlVN?: string | undefined;
    labelControlCN?: string | undefined;
    labelRequired?: boolean | undefined;
    visible?: boolean | undefined;
    disabled?: boolean | undefined;
    readOnly?: boolean | undefined;
    required?: boolean | undefined;
    showClearButton?: boolean | undefined;
    label?: string | undefined;
    placeholder?: string | undefined;
    mode?: string | undefined;
    mask?: string | undefined;
    maskRules?: string | undefined;
    groupId?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    typeControl?: string | undefined;
    format?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;
    number_order?: number | undefined;
    displayFormat?: string | undefined;
    type?: string | undefined;
    query?: string | undefined;

    constructor(data?: ISysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.code = _data["code"];
            this.labelModel = _data["labelModel"];
            this.edit = _data["edit"];
            this.labelControl = _data["labelControl"];
            this.labelControlVN = _data["labelControlVN"];
            this.labelControlCN = _data["labelControlCN"];
            this.labelRequired = _data["labelRequired"];
            this.visible = _data["visible"];
            this.disabled = _data["disabled"];
            this.readOnly = _data["readOnly"];
            this.required = _data["required"];
            this.showClearButton = _data["showClearButton"];
            this.label = _data["label"];
            this.placeholder = _data["placeholder"];
            this.mode = _data["mode"];
            this.mask = _data["mask"];
            this.maskRules = _data["maskRules"];
            this.groupId = _data["groupId"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.companyCode = _data["companyCode"];
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.typeControl = _data["typeControl"];
            this.format = _data["format"];
            this.description = _data["description"];
            this.description1 = _data["description1"];
            this.description2 = _data["description2"];
            this.description3 = _data["description3"];
            this.number_order = _data["number_order"];
            this.displayFormat = _data["displayFormat"];
            this.type = _data["type"];
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): SysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new SysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["code"] = this.code;
        data["labelModel"] = this.labelModel;
        data["edit"] = this.edit;
        data["labelControl"] = this.labelControl;
        data["labelControlVN"] = this.labelControlVN;
        data["labelControlCN"] = this.labelControlCN;
        data["labelRequired"] = this.labelRequired;
        data["visible"] = this.visible;
        data["disabled"] = this.disabled;
        data["readOnly"] = this.readOnly;
        data["required"] = this.required;
        data["showClearButton"] = this.showClearButton;
        data["label"] = this.label;
        data["placeholder"] = this.placeholder;
        data["mode"] = this.mode;
        data["mask"] = this.mask;
        data["maskRules"] = this.maskRules;
        data["groupId"] = this.groupId;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["companyCode"] = this.companyCode;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["typeControl"] = this.typeControl;
        data["format"] = this.format;
        data["description"] = this.description;
        data["description1"] = this.description1;
        data["description2"] = this.description2;
        data["description3"] = this.description3;
        data["number_order"] = this.number_order;
        data["displayFormat"] = this.displayFormat;
        data["type"] = this.type;
        data["query"] = this.query;
        return data;
    }
}

export interface ISysVoucherFormColumn {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    labelModel?: string | undefined;
    edit?: boolean | undefined;
    labelControl?: string | undefined;
    labelControlVN?: string | undefined;
    labelControlCN?: string | undefined;
    labelRequired?: boolean | undefined;
    visible?: boolean | undefined;
    disabled?: boolean | undefined;
    readOnly?: boolean | undefined;
    required?: boolean | undefined;
    showClearButton?: boolean | undefined;
    label?: string | undefined;
    placeholder?: string | undefined;
    mode?: string | undefined;
    mask?: string | undefined;
    maskRules?: string | undefined;
    groupId?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    typeControl?: string | undefined;
    format?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;
    number_order?: number | undefined;
    displayFormat?: string | undefined;
    type?: string | undefined;
    query?: string | undefined;
}

export class StatusMessageOfListOfSysVoucherFormColumn implements IStatusMessageOfListOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysVoucherFormColumn.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysVoucherFormGroup implements IStatusMessageOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysVoucherFormGroup.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup | undefined;
    currentID?: string | undefined;
}

export class SysVoucherFormGroup implements ISysVoucherFormGroup {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    group_id?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;

    constructor(data?: ISysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.code = _data["code"];
            this.name1 = _data["name1"];
            this.name2 = _data["name2"];
            this.name3 = _data["name3"];
            this.number_order = _data["number_order"];
            this.group_id = _data["group_id"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            this.companyCode = _data["companyCode"];
            this.description = _data["description"];
            this.description1 = _data["description1"];
            this.description2 = _data["description2"];
            this.description3 = _data["description3"];
        }
    }

    static fromJS(data: any): SysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["code"] = this.code;
        data["name1"] = this.name1;
        data["name2"] = this.name2;
        data["name3"] = this.name3;
        data["number_order"] = this.number_order;
        data["group_id"] = this.group_id;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        data["companyCode"] = this.companyCode;
        data["description"] = this.description;
        data["description1"] = this.description1;
        data["description2"] = this.description2;
        data["description3"] = this.description3;
        return data;
    }
}

export interface ISysVoucherFormGroup {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    group_id?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    companyCode?: string | undefined;
    description?: string | undefined;
    description1?: string | undefined;
    description2?: string | undefined;
    description3?: string | undefined;
}

export class StatusMessageOfListOfSysVoucherFormGroup implements IStatusMessageOfListOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysVoucherFormGroup.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup[] | undefined;
    currentID?: string | undefined;
}

export class CurrentJobPosition implements ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;

    constructor(data?: ICurrentJobPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.jobDescription = _data["jobDescription"];
            this.departmentOrTeam = _data["departmentOrTeam"];
            this.positionAndLevel = _data["positionAndLevel"];
            this.workSchedule = _data["workSchedule"];
            this.currentProjects = _data["currentProjects"];
            this.goalsAndDevelopment = _data["goalsAndDevelopment"];
        }
    }

    static fromJS(data: any): CurrentJobPosition {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentJobPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["jobDescription"] = this.jobDescription;
        data["departmentOrTeam"] = this.departmentOrTeam;
        data["positionAndLevel"] = this.positionAndLevel;
        data["workSchedule"] = this.workSchedule;
        data["currentProjects"] = this.currentProjects;
        data["goalsAndDevelopment"] = this.goalsAndDevelopment;
        return data;
    }
}

export interface ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;
}

export class SalaryAndBenefits implements ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;

    constructor(data?: ISalaryAndBenefits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.salary = _data["salary"];
            this.benefits = _data["benefits"];
            this.wagesAndPerks = _data["wagesAndPerks"];
            this.compensationPackageAmount = _data["compensationPackageAmount"];
            this.compensationPackage = _data["compensationPackage"];
            this.compensationPackageAmount1 = _data["compensationPackageAmount1"];
            this.compensationPackage1 = _data["compensationPackage1"];
            this.compensationPackageAmount2 = _data["compensationPackageAmount2"];
            this.compensationPackage2 = _data["compensationPackage2"];
            this.compensationPackageAmount3 = _data["compensationPackageAmount3"];
            this.compensationPackage3 = _data["compensationPackage3"];
            this.insuranceCoverage = _data["insuranceCoverage"];
            this.allowancesAndAidsAmount = _data["allowancesAndAidsAmount"];
            this.allowancesAndAids = _data["allowancesAndAids"];
            this.allowancesAndAidsAmount1 = _data["allowancesAndAidsAmount1"];
            this.allowancesAndAids1 = _data["allowancesAndAids1"];
            this.allowancesAndAidsAmount2 = _data["allowancesAndAidsAmount2"];
            this.allowancesAndAids2 = _data["allowancesAndAids2"];
            this.allowancesAndAidsAmount3 = _data["allowancesAndAidsAmount3"];
            this.allowancesAndAids3 = _data["allowancesAndAids3"];
        }
    }

    static fromJS(data: any): SalaryAndBenefits {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryAndBenefits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["salary"] = this.salary;
        data["benefits"] = this.benefits;
        data["wagesAndPerks"] = this.wagesAndPerks;
        data["compensationPackageAmount"] = this.compensationPackageAmount;
        data["compensationPackage"] = this.compensationPackage;
        data["compensationPackageAmount1"] = this.compensationPackageAmount1;
        data["compensationPackage1"] = this.compensationPackage1;
        data["compensationPackageAmount2"] = this.compensationPackageAmount2;
        data["compensationPackage2"] = this.compensationPackage2;
        data["compensationPackageAmount3"] = this.compensationPackageAmount3;
        data["compensationPackage3"] = this.compensationPackage3;
        data["insuranceCoverage"] = this.insuranceCoverage;
        data["allowancesAndAidsAmount"] = this.allowancesAndAidsAmount;
        data["allowancesAndAids"] = this.allowancesAndAids;
        data["allowancesAndAidsAmount1"] = this.allowancesAndAidsAmount1;
        data["allowancesAndAids1"] = this.allowancesAndAids1;
        data["allowancesAndAidsAmount2"] = this.allowancesAndAidsAmount2;
        data["allowancesAndAids2"] = this.allowancesAndAids2;
        data["allowancesAndAidsAmount3"] = this.allowancesAndAidsAmount3;
        data["allowancesAndAids3"] = this.allowancesAndAids3;
        return data;
    }
}

export interface ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;
}

export class WorkHistory implements IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;

    constructor(data?: IWorkHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.companyAndPosition = _data["companyAndPosition"];
            this.workHistoryStart = _data["workHistoryStart"] ? new Date(_data["workHistoryStart"].toString()) : <any>undefined;
            this.workHistoryEnd = _data["workHistoryEnd"] ? new Date(_data["workHistoryEnd"].toString()) : <any>undefined;
            this.timeWorked = _data["timeWorked"];
            this.jobdeScription = _data["jobdeScription"];
            this.achievementSkills = _data["achievementSkills"];
            this.reasonForChange = _data["reasonForChange"];
        }
    }

    static fromJS(data: any): WorkHistory {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["companyAndPosition"] = this.companyAndPosition;
        data["workHistoryStart"] = this.workHistoryStart ? this.workHistoryStart.toISOString() : <any>undefined;
        data["workHistoryEnd"] = this.workHistoryEnd ? this.workHistoryEnd.toISOString() : <any>undefined;
        data["timeWorked"] = this.timeWorked;
        data["jobdeScription"] = this.jobdeScription;
        data["achievementSkills"] = this.achievementSkills;
        data["reasonForChange"] = this.reasonForChange;
        return data;
    }
}

export interface IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;
}

export class AccountClientLoginParamsModel implements IAccountClientLoginParamsModel {
    account?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;

    constructor(data?: IAccountClientLoginParamsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.companyCode = _data["companyCode"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.ip_address = _data["ip_address"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): AccountClientLoginParamsModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientLoginParamsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["companyCode"] = this.companyCode;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["ip_address"] = this.ip_address;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IAccountClientLoginParamsModel {
    account?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
}

export class AccountClientProfileModel implements IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;

    constructor(data?: IAccountClientProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            this.userInfo = _data["userInfo"] ? UserInfo.fromJS(_data["userInfo"]) : <any>undefined;
            this.token = _data["token"] ? TOKEN.fromJS(_data["token"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountClientProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["userInfo"] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
        data["token"] = this.token ? this.token.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;
}

export class Account implements IAccount {
    account?: string | undefined;
    password?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;
    language?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.status = _data["status"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.type_account = _data["type_account"];
            this.token = _data["token"];
            this.codePermision = _data["codePermision"];
            this.companyCode = _data["companyCode"];
            this.namePermision = _data["namePermision"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["status"] = this.status;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["type_account"] = this.type_account;
        data["token"] = this.token;
        data["codePermision"] = this.codePermision;
        data["companyCode"] = this.companyCode;
        data["namePermision"] = this.namePermision;
        data["language"] = this.language;
        return data;
    }
}

export interface IAccount {
    account?: string | undefined;
    password?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;
    language?: string | undefined;
}

export class UserInfo implements IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        return data;
    }
}

export interface IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
}

export class TOKEN implements ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;

    constructor(data?: ITOKEN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.username = _data["username"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.last_date_connect = _data["last_date_connect"] ? new Date(_data["last_date_connect"].toString()) : <any>undefined;
            this.is_connecting = _data["is_connecting"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ip_address = _data["ip_address"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.connectionSignalID = _data["connectionSignalID"];
        }
    }

    static fromJS(data: any): TOKEN {
        data = typeof data === 'object' ? data : {};
        let result = new TOKEN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["username"] = this.username;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["last_date_connect"] = this.last_date_connect ? this.last_date_connect.toISOString() : <any>undefined;
        data["is_connecting"] = this.is_connecting;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ip_address"] = this.ip_address;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["connectionSignalID"] = this.connectionSignalID;
        return data;
    }
}

export interface ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;
}

export class StatusMessageOfListOfCategoryCommonModel implements IStatusMessageOfListOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfCategoryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryCommonModel.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfCategoryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfCategoryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel[] | undefined;
    currentID?: string | undefined;
}

export class CategoryCommonModel implements ICategoryCommonModel {
    id?: string | undefined;
    group_id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    description?: string | undefined;
    company_code?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    items?: CategoryCommonModel[] | undefined;

    constructor(data?: ICategoryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.group_id = _data["group_id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.name1 = _data["name1"];
            this.name2 = _data["name2"];
            this.name3 = _data["name3"];
            this.number_order = _data["number_order"];
            this.description = _data["description"];
            this.company_code = _data["company_code"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.create_by = _data["create_by"];
            this.update_by = _data["update_by"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryCommonModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["group_id"] = this.group_id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["name1"] = this.name1;
        data["name2"] = this.name2;
        data["name3"] = this.name3;
        data["number_order"] = this.number_order;
        data["description"] = this.description;
        data["company_code"] = this.company_code;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["create_by"] = this.create_by;
        data["update_by"] = this.update_by;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryCommonModel {
    id?: string | undefined;
    group_id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    name1?: string | undefined;
    name2?: string | undefined;
    name3?: string | undefined;
    number_order?: number | undefined;
    description?: string | undefined;
    company_code?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    create_by?: string | undefined;
    update_by?: string | undefined;
    items?: CategoryCommonModel[] | undefined;
}

export class StatusMessageOfCategoryCommonModel implements IStatusMessageOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfCategoryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? CategoryCommonModel.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfCategoryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfCategoryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfCategoryCommonModel {
    status?: number | undefined;
    msg?: string | undefined;
    data?: CategoryCommonModel | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfNational implements IStatusMessageOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfNational) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? National.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfNational {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfNational();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National | undefined;
    currentID?: string | undefined;
}

export class National implements INational {
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    language?: string | undefined;
    zip_code?: string | undefined;
    active?: boolean | undefined;

    constructor(data?: INational) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.language = _data["language"];
            this.zip_code = _data["zip_code"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): National {
        data = typeof data === 'object' ? data : {};
        let result = new National();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["language"] = this.language;
        data["zip_code"] = this.zip_code;
        data["active"] = this.active;
        return data;
    }
}

export interface INational {
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    language?: string | undefined;
    zip_code?: string | undefined;
    active?: boolean | undefined;
}

export class StatusMessageOfListOfNational implements IStatusMessageOfListOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfNational) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(National.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfNational {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfNational();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfNational {
    status?: number | undefined;
    msg?: string | undefined;
    data?: National[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysPermission implements IStatusMessageOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysPermission.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission | undefined;
    currentID?: string | undefined;
}

export class SysPermission implements ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: number | undefined;
    codeCompany?: string | undefined;

    constructor(data?: ISysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.order_number = _data["order_number"];
            this.codeCompany = _data["codeCompany"];
        }
    }

    static fromJS(data: any): SysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new SysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["order_number"] = this.order_number;
        data["codeCompany"] = this.codeCompany;
        return data;
    }
}

export interface ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: number | undefined;
    codeCompany?: string | undefined;
}

export class StatusMessageOfListOfSysPermission implements IStatusMessageOfListOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysPermission.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysPermission {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysPermission[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysStatus implements IStatusMessageOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysStatus.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus | undefined;
    currentID?: string | undefined;
}

export class SysStatus implements ISysStatus {
    id?: string | undefined;
    module?: string | undefined;
    appModule?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    order_numer?: number | undefined;
    enable?: boolean | undefined;
    accept_login?: boolean | undefined;

    constructor(data?: ISysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.module = _data["module"];
            this.appModule = _data["appModule"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.order_numer = _data["order_numer"];
            this.enable = _data["enable"];
            this.accept_login = _data["accept_login"];
        }
    }

    static fromJS(data: any): SysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["module"] = this.module;
        data["appModule"] = this.appModule;
        data["code"] = this.code;
        data["name"] = this.name;
        data["order_numer"] = this.order_numer;
        data["enable"] = this.enable;
        data["accept_login"] = this.accept_login;
        return data;
    }
}

export interface ISysStatus {
    id?: string | undefined;
    module?: string | undefined;
    appModule?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    order_numer?: number | undefined;
    enable?: boolean | undefined;
    accept_login?: boolean | undefined;
}

export class StatusMessageOfListOfSysStatus implements IStatusMessageOfListOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysStatus.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysStatus {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysStatus[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysTypeAccount implements IStatusMessageOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysTypeAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysTypeAccount.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysTypeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysTypeAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount | undefined;
    currentID?: string | undefined;
}

export class SysTypeAccount implements ISysTypeAccount {
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: ISysTypeAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SysTypeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new SysTypeAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface ISysTypeAccount {
    code?: string | undefined;
    name?: string | undefined;
}

export class StatusMessageOfListOfSysTypeAccount implements IStatusMessageOfListOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysTypeAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysTypeAccount.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysTypeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysTypeAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysTypeAccount {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysTypeAccount[] | undefined;
    currentID?: string | undefined;
}

export class Sys_Menu_Tree_View_MODEL extends SysMenu implements ISys_Menu_Tree_View_MODEL {
    items?: Sys_Menu_Tree_View_MODEL[] | undefined;
    expanded?: boolean | undefined;
    selected?: boolean | undefined;
    account?: string | undefined;

    constructor(data?: ISys_Menu_Tree_View_MODEL) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            this.expanded = _data["expanded"];
            this.selected = _data["selected"];
            this.account = _data["account"];
        }
    }

    static override fromJS(data: any): Sys_Menu_Tree_View_MODEL {
        data = typeof data === 'object' ? data : {};
        let result = new Sys_Menu_Tree_View_MODEL();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["expanded"] = this.expanded;
        data["selected"] = this.selected;
        data["account"] = this.account;
        super.toJSON(data);
        return data;
    }
}

export interface ISys_Menu_Tree_View_MODEL extends ISysMenu {
    items?: Sys_Menu_Tree_View_MODEL[] | undefined;
    expanded?: boolean | undefined;
    selected?: boolean | undefined;
    account?: string | undefined;
}

export class UserInformationClientGetUser implements IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[] | undefined;

    constructor(data?: IUserInformationClientGetUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
            this.nameCompany = _data["nameCompany"];
            this.email = _data["email"];
            this.nameDepartment = _data["nameDepartment"];
            this.nameBrach = _data["nameBrach"];
            this.codeDepartment = _data["codeDepartment"];
            this.codeName = _data["codeName"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(TOKEN.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInformationClientGetUser {
        data = typeof data === 'object' ? data : {};
        let result = new UserInformationClientGetUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        data["nameCompany"] = this.nameCompany;
        data["email"] = this.email;
        data["nameDepartment"] = this.nameDepartment;
        data["nameBrach"] = this.nameBrach;
        data["codeDepartment"] = this.codeDepartment;
        data["codeName"] = this.codeName;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[] | undefined;
}

export class Company implements ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.adminCompany = _data["adminCompany"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["adminCompany"] = this.adminCompany;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;
}

export class QueryCommonModel implements IQueryCommonModel {
    table_name?: string | undefined;
    action?: string | undefined;
    string_query?: string | undefined;

    constructor(data?: IQueryCommonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.table_name = _data["table_name"];
            this.action = _data["action"];
            this.string_query = _data["string_query"];
        }
    }

    static fromJS(data: any): QueryCommonModel {
        data = typeof data === 'object' ? data : {};
        let result = new QueryCommonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["table_name"] = this.table_name;
        data["action"] = this.action;
        data["string_query"] = this.string_query;
        return data;
    }
}

export interface IQueryCommonModel {
    table_name?: string | undefined;
    action?: string | undefined;
    string_query?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}