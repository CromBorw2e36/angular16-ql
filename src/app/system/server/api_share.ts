//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import LayoutComponentBase from 'src/app/share/layoutBase/LayoutComponentBase';
import { Injector } from '@angular/core';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { APIBase } from './APIBase';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ISysActionClient {
    sysActionIns(action: SysAction): Observable<StatusMessageOfSysAction>;
    sysActionUpd(action: SysAction): Observable<StatusMessageOfObject>;
    sysActionDel(action: SysAction): Observable<StatusMessageOfObject>;
    sysActionGetByCode(code?: string | undefined): Observable<SysAction>;
    sysActionGetByCodeByPermision(actionCode?: string | undefined): Observable<SysAction[]>;
    sysDropDownActionIns(dropdownAction: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction>;
    sysDropdownActionUpd(action: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction>;
    sysDropdownActionDel(action: SysDropDownAction): Observable<StatusMessageOfObject>;
    sysDropActionGetListSysActionByCode(dropdownAction: SysDropDownAction): Observable<SysAction[]>;
    sysDropdownActionGet(actionCode: SysDropDownAction): Observable<SysDropDownAction>;
    getListActionByGroupCode(groupAction: SysGroupAction): Observable<StatusMessageOfListOfSysAction>;
}

@Injectable()
export class SysActionClient extends APIBase implements ISysActionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    sysActionIns(action: SysAction): Observable<StatusMessageOfSysAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysAction>;
        }));
    }

    protected processSysActionIns(response: HttpResponseBase): Observable<StatusMessageOfSysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionUpd(action: SysAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionUpd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionUpd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionUpd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysActionUpd(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionDel(action: SysAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionDel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysActionDel(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionGetByCode(code?: string | undefined): Observable<SysAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionGetByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionGetByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction>;
        }));
    }

    protected processSysActionGetByCode(response: HttpResponseBase): Observable<SysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysActionGetByCodeByPermision(actionCode?: string | undefined): Observable<SysAction[]> {
        let url_ = this.baseUrl + "/api/sysAction/SysActionGetByCode2?";
        if (actionCode === null)
            throw new Error("The parameter 'actionCode' cannot be null.");
        else if (actionCode !== undefined)
            url_ += "actionCode=" + encodeURIComponent("" + actionCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysActionGetByCodeByPermision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysActionGetByCodeByPermision(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction[]>;
        }));
    }

    protected processSysActionGetByCodeByPermision(response: HttpResponseBase): Observable<SysAction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropDownActionIns(dropdownAction: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropDownActionIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dropdownAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropDownActionIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropDownActionIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysDropDownAction>;
        }));
    }

    protected processSysDropDownActionIns(response: HttpResponseBase): Observable<StatusMessageOfSysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionUpd(action: SysDropDownAction): Observable<StatusMessageOfSysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropdownActionUpd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionUpd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionUpd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysDropDownAction>;
        }));
    }

    protected processSysDropdownActionUpd(response: HttpResponseBase): Observable<StatusMessageOfSysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionDel(action: SysDropDownAction): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropdownActionDel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(action);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionDel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionDel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processSysDropdownActionDel(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropActionGetListSysActionByCode(dropdownAction: SysDropDownAction): Observable<SysAction[]> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropActionGetListSysActionByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dropdownAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropActionGetListSysActionByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropActionGetListSysActionByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysAction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysAction[]>;
        }));
    }

    protected processSysDropActionGetListSysActionByCode(response: HttpResponseBase): Observable<SysAction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sysDropdownActionGet(actionCode: SysDropDownAction): Observable<SysDropDownAction> {
        let url_ = this.baseUrl + "/api/sysAction/SysDropActionGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionCode);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSysDropdownActionGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSysDropdownActionGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysDropDownAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysDropDownAction>;
        }));
    }

    protected processSysDropdownActionGet(response: HttpResponseBase): Observable<SysDropDownAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysDropDownAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListActionByGroupCode(groupAction: SysGroupAction): Observable<StatusMessageOfListOfSysAction> {
        let url_ = this.baseUrl + "/api/sysAction/GetListActionByGroupCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupAction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListActionByGroupCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListActionByGroupCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysAction>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysAction>;
        }));
    }

    protected processGetListActionByGroupCode(response: HttpResponseBase): Observable<StatusMessageOfListOfSysAction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysAction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysGenRowTablesClient {
    genRowTableInsert(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableUpdate(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableDelete(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable>;
    genRowTableSearch(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfListOfSysGenRowTable>;
}

@Injectable()
export class SysGenRowTablesClient extends APIBase implements ISysGenRowTablesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    genRowTableInsert(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableInsert(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableUpdate(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableDelete(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableDelete(response: HttpResponseBase): Observable<StatusMessageOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    genRowTableSearch(sysGenRowTable: SysGenRowTable): Observable<StatusMessageOfListOfSysGenRowTable> {
        let url_ = this.baseUrl + "/api/SysGenRowTables/Gen_Row_Table_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysGenRowTable);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenRowTableSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenRowTableSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysGenRowTable>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysGenRowTable>;
        }));
    }

    protected processGenRowTableSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysGenRowTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysGenRowTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISysVoucherFormClient {
    voucherFormColumnInsert(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnUpdate(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnDelete(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn>;
    voucherFormColumnSearch(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfListOfSysVoucherFormColumn>;
    voucherFormGroupInsert(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupUpdate(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupDelete(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup>;
    voucherFormGroupSearch(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfListOfSysVoucherFormGroup>;
}

@Injectable()
export class SysVoucherFormClient extends APIBase implements ISysVoucherFormClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    voucherFormColumnInsert(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnInsert(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnUpdate(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnDelete(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnDelete(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormColumnSearch(sysVoucherFormColumn: SysVoucherFormColumn): Observable<StatusMessageOfListOfSysVoucherFormColumn> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Column_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormColumn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormColumnSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormColumnSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysVoucherFormColumn>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysVoucherFormColumn>;
        }));
    }

    protected processVoucherFormColumnSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysVoucherFormColumn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysVoucherFormColumn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupInsert(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupInsert(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupUpdate(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupUpdate(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupDelete(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupDelete(response: HttpResponseBase): Observable<StatusMessageOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    voucherFormGroupSearch(sysVoucherFormGroup: SysVoucherFormGroup): Observable<StatusMessageOfListOfSysVoucherFormGroup> {
        let url_ = this.baseUrl + "/api/SysVoucherForm/Voucher_Form_Group_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sysVoucherFormGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVoucherFormGroupSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoucherFormGroupSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfListOfSysVoucherFormGroup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfListOfSysVoucherFormGroup>;
        }));
    }

    protected processVoucherFormGroupSearch(response: HttpResponseBase): Observable<StatusMessageOfListOfSysVoucherFormGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfListOfSysVoucherFormGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICurrentJobPositionsClient {
    getCurrentJobPositions(): Observable<CurrentJobPosition[]>;
    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition>;
    getCurrentJobPosition(id: string): Observable<CurrentJobPosition>;
    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse>;
    deleteCurrentJobPosition(id: string): Observable<FileResponse>;
}

@Injectable()
export class CurrentJobPositionsClient extends APIBase implements ICurrentJobPositionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getCurrentJobPositions(): Observable<CurrentJobPosition[]> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition[]>;
        }));
    }

    protected processGetCurrentJobPositions(response: HttpResponseBase): Observable<CurrentJobPosition[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrentJobPosition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processPostCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrentJobPosition(id: string): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processGetCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCurrentJobPosition(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISalaryAndBenefitsClient {
    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]>;
    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits>;
    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits>;
    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse>;
    deleteSalaryAndBenefits(id: string): Observable<FileResponse>;
}

@Injectable()
export class SalaryAndBenefitsClient extends APIBase implements ISalaryAndBenefitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefitsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefitsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits[]>;
        }));
    }

    protected processGetSalaryAndBenefitsAll(response: HttpResponseBase): Observable<SalaryAndBenefits[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalaryAndBenefits.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processPostSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processGetSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSalaryAndBenefits(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWorkHistoriesClient {
    getWorkHistories(): Observable<WorkHistory[]>;
    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory>;
    getWorkHistory(id: string): Observable<WorkHistory>;
    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse>;
    deleteWorkHistory(id: string): Observable<FileResponse>;
}

@Injectable()
export class WorkHistoriesClient extends APIBase implements IWorkHistoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getWorkHistories(): Observable<WorkHistory[]> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory[]>;
        }));
    }

    protected processGetWorkHistories(response: HttpResponseBase): Observable<WorkHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processPostWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWorkHistory(id: string): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processGetWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWorkHistory(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAccountsClient {
    checkTheExpirationDateOfToken(): Observable<boolean>;
    login(account: AccountClientLoginParamsModel): Observable<StatusMessageOfObject>;
    accountIns(profile: AccountClientProfileModel): Observable<StatusMessageOfObject>;
    updateAccount(account: Account): Observable<StatusMessageOfObject>;
    deleteAccount(id: string): Observable<StatusMessageOfObject>;
}

@Injectable()
export class AccountsClient extends APIBase implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    checkTheExpirationDateOfToken(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Accounts/CheckTheExpirationDateOfToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckTheExpirationDateOfToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTheExpirationDateOfToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckTheExpirationDateOfToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(account: AccountClientLoginParamsModel): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountIns(profile: AccountClientProfileModel): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/AccountIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processAccountIns(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAccount(account: Account): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/UpdateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAccount(id: string): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMenuPermissionsClient {
    getListMenu(): Observable<SysMenu[]>;
    getListMenuV2(): Observable<SysMenu[]>;
    listMenuTreeView(): Observable<Sys_Menu_Tree_View_MODEL[]>;
    listMenuById(p: Sys_Menu_Tree_View_MODEL): Observable<Sys_Menu_Tree_View_MODEL[]>;
    getAllListMenu(): Observable<SysMenu>;
}

@Injectable()
export class MenuPermissionsClient extends APIBase implements IMenuPermissionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getListMenu(): Observable<SysMenu[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu[]>;
        }));
    }

    protected processGetListMenu(response: HttpResponseBase): Observable<SysMenu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysMenu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListMenuV2(): Observable<SysMenu[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/sys_menu_get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListMenuV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMenuV2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu[]>;
        }));
    }

    protected processGetListMenuV2(response: HttpResponseBase): Observable<SysMenu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysMenu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listMenuTreeView(): Observable<Sys_Menu_Tree_View_MODEL[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_tree_view";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListMenuTreeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMenuTreeView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
        }));
    }

    protected processListMenuTreeView(response: HttpResponseBase): Observable<Sys_Menu_Tree_View_MODEL[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listMenuById(p: Sys_Menu_Tree_View_MODEL): Observable<Sys_Menu_Tree_View_MODEL[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_by_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(p);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListMenuById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListMenuById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sys_Menu_Tree_View_MODEL[]>;
        }));
    }

    protected processListMenuById(response: HttpResponseBase): Observable<Sys_Menu_Tree_View_MODEL[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllListMenu(): Observable<SysMenu> {
        let url_ = this.baseUrl + "/api/MenuPermissions/list_menu_get_all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllListMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllListMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu>;
        }));
    }

    protected processGetAllListMenu(response: HttpResponseBase): Observable<SysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserInfoesClient {
    userIns(userInfo: UserInfo): Observable<StatusMessageOfObject>;
    updUser(userInfo: UserInfo): Observable<StatusMessageOfObject>;
    getMyUser(): Observable<UserInfo>;
    getLstUser(): Observable<UserInfo[]>;
    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser>;
    deleteUserInfo(id: string): Observable<FileResponse>;
}

@Injectable()
export class UserInfoesClient extends APIBase implements IUserInfoesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    userIns(userInfo: UserInfo): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/UserInfoes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUserIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUserIns(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updUser(userInfo: UserInfo): Observable<StatusMessageOfObject> {
        let url_ = this.baseUrl + "/api/UserInfoes/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessageOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessageOfObject>;
        }));
    }

    protected processUpdUser(response: HttpResponseBase): Observable<StatusMessageOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessageOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyUser(): Observable<UserInfo> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMyUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo>;
        }));
    }

    protected processGetMyUser(response: HttpResponseBase): Observable<UserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLstUser(): Observable<UserInfo[]> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLstUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLstUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo[]>;
        }));
    }

    protected processGetLstUser(response: HttpResponseBase): Observable<UserInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUserInformation?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInformationClientGetUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInformationClientGetUser>;
        }));
    }

    protected processGetUserInformation(response: HttpResponseBase): Observable<UserInformationClientGetUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInformationClientGetUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUserInfo(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserInfoes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteUserInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICommonContronllerClient {
    listCompany(): Observable<Company[]>;
    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]>;
    getPermissionByCompany(): Observable<SysPermission[]>;
}

@Injectable()
export class CommonContronllerClient extends APIBase implements ICommonContronllerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    listCompany(): Observable<Company[]> {
        let url_ = this.baseUrl + "/api/CommonContronller";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Company[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Company[]>;
        }));
    }

    protected processListCompany(response: HttpResponseBase): Observable<Company[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Company.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListStatusByModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pSysStatus);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatusByModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysStatus[]>;
        }));
    }

    protected processGetStatusByModule(response: HttpResponseBase): Observable<SysStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPermissionByCompany(): Observable<SysPermission[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListPermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionByCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionByCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysPermission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysPermission[]>;
        }));
    }

    protected processGetPermissionByCompany(response: HttpResponseBase): Observable<SysPermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysPermission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class StatusMessageOfSysAction implements IStatusMessageOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysAction.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction | undefined;
    currentID?: string | undefined;
}

export class SysAction implements ISysAction {
    code?: string | undefined;
    nameVn?: string | undefined;
    nameOther?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    isDisable?: boolean | undefined;
    description?: string | undefined;
    url_1?: string | undefined;
    url_2?: string | undefined;
    url_3?: string | undefined;
    url_4?: string | undefined;
    isClocked?: boolean | undefined;
    codeGroup?: string | undefined;
    orderNo?: number | undefined;

    constructor(data?: ISysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.nameVn = _data["nameVn"];
            this.nameOther = _data["nameOther"];
            this.icon = _data["icon"];
            this.color = _data["color"];
            this.backgroundColor = _data["backgroundColor"];
            this.isDisable = _data["isDisable"];
            this.description = _data["description"];
            this.url_1 = _data["url_1"];
            this.url_2 = _data["url_2"];
            this.url_3 = _data["url_3"];
            this.url_4 = _data["url_4"];
            this.isClocked = _data["isClocked"];
            this.codeGroup = _data["codeGroup"];
            this.orderNo = _data["orderNo"];
        }
    }

    static fromJS(data: any): SysAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["nameVn"] = this.nameVn;
        data["nameOther"] = this.nameOther;
        data["icon"] = this.icon;
        data["color"] = this.color;
        data["backgroundColor"] = this.backgroundColor;
        data["isDisable"] = this.isDisable;
        data["description"] = this.description;
        data["url_1"] = this.url_1;
        data["url_2"] = this.url_2;
        data["url_3"] = this.url_3;
        data["url_4"] = this.url_4;
        data["isClocked"] = this.isClocked;
        data["codeGroup"] = this.codeGroup;
        data["orderNo"] = this.orderNo;
        return data;
    }
}

export interface ISysAction {
    code?: string | undefined;
    nameVn?: string | undefined;
    nameOther?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    isDisable?: boolean | undefined;
    description?: string | undefined;
    url_1?: string | undefined;
    url_2?: string | undefined;
    url_3?: string | undefined;
    url_4?: string | undefined;
    isClocked?: boolean | undefined;
    codeGroup?: string | undefined;
    orderNo?: number | undefined;
}

export class StatusMessageOfObject implements IStatusMessageOfObject {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"];
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfObject {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfObject {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysDropDownAction implements IStatusMessageOfSysDropDownAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysDropDownAction | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysDropDownAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysDropDownAction.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysDropDownAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysDropDownAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysDropDownAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysDropDownAction | undefined;
    currentID?: string | undefined;
}

export class SysDropDownAction implements ISysDropDownAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;

    constructor(data?: ISysDropDownAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.codeAction = _data["codeAction"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
            this.isClocked = _data["isClocked"];
        }
    }

    static fromJS(data: any): SysDropDownAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysDropDownAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["codeAction"] = this.codeAction;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        data["isClocked"] = this.isClocked;
        return data;
    }
}

export interface ISysDropDownAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
}

export class StatusMessageOfListOfSysAction implements IStatusMessageOfListOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysAction.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysAction {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysAction {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysAction[] | undefined;
    currentID?: string | undefined;
}

export class SysGroupAction implements ISysGroupAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
    isDropDown?: boolean | undefined;
    listChildAction?: SysAction[] | undefined;

    constructor(data?: ISysGroupAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.codeAction = _data["codeAction"];
            this.orderNo = _data["orderNo"];
            this.description = _data["description"];
            this.isClocked = _data["isClocked"];
            this.isDropDown = _data["isDropDown"];
            if (Array.isArray(_data["listChildAction"])) {
                this.listChildAction = [] as any;
                for (let item of _data["listChildAction"])
                    this.listChildAction!.push(SysAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SysGroupAction {
        data = typeof data === 'object' ? data : {};
        let result = new SysGroupAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["codeAction"] = this.codeAction;
        data["orderNo"] = this.orderNo;
        data["description"] = this.description;
        data["isClocked"] = this.isClocked;
        data["isDropDown"] = this.isDropDown;
        if (Array.isArray(this.listChildAction)) {
            data["listChildAction"] = [];
            for (let item of this.listChildAction)
                data["listChildAction"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISysGroupAction {
    code?: string | undefined;
    codeAction?: string | undefined;
    orderNo?: number | undefined;
    description?: string | undefined;
    isClocked?: boolean | undefined;
    isDropDown?: boolean | undefined;
    listChildAction?: SysAction[] | undefined;
}

export class StatusMessageOfSysGenRowTable implements IStatusMessageOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysGenRowTable.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable | undefined;
    currentID?: string | undefined;
}

export class SysGenRowTable implements ISysGenRowTable {
    id?: string | undefined;
    table_name?: string | undefined;
    dataField?: string | undefined;
    caption?: string | undefined;
    caption_VN?: string | undefined;
    name?: string | undefined;
    dataType?: string | undefined;
    format?: string | undefined;
    width?: number | undefined;
    visible?: boolean | undefined;
    minWidth?: number | undefined;
    alignment?: string | undefined;
    allowEditing?: boolean | undefined;
    allowFiltering?: boolean | undefined;
    allowFixing?: boolean | undefined;
    allowGrouping?: boolean | undefined;
    allowHeaderFiltering?: boolean | undefined;
    allowHiding?: boolean | undefined;
    allowSearch?: boolean | undefined;
    allowSorting?: boolean | undefined;
    autoExpandGroup?: boolean | undefined;
    columns?: SysGenRowTable[] | undefined;
    column_child?: string | undefined;
    cssClass?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    orderNo?: number | undefined;

    constructor(data?: ISysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.dataField = _data["dataField"];
            this.caption = _data["caption"];
            this.caption_VN = _data["caption_VN"];
            this.name = _data["name"];
            this.dataType = _data["dataType"];
            this.format = _data["format"];
            this.width = _data["width"];
            this.visible = _data["visible"];
            this.minWidth = _data["minWidth"];
            this.alignment = _data["alignment"];
            this.allowEditing = _data["allowEditing"];
            this.allowFiltering = _data["allowFiltering"];
            this.allowFixing = _data["allowFixing"];
            this.allowGrouping = _data["allowGrouping"];
            this.allowHeaderFiltering = _data["allowHeaderFiltering"];
            this.allowHiding = _data["allowHiding"];
            this.allowSearch = _data["allowSearch"];
            this.allowSorting = _data["allowSorting"];
            this.autoExpandGroup = _data["autoExpandGroup"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(SysGenRowTable.fromJS(item));
            }
            this.column_child = _data["column_child"];
            this.cssClass = _data["cssClass"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.companyCode = _data["companyCode"];
            this.orderNo = _data["orderNo"];
        }
    }

    static fromJS(data: any): SysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new SysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["dataField"] = this.dataField;
        data["caption"] = this.caption;
        data["caption_VN"] = this.caption_VN;
        data["name"] = this.name;
        data["dataType"] = this.dataType;
        data["format"] = this.format;
        data["width"] = this.width;
        data["visible"] = this.visible;
        data["minWidth"] = this.minWidth;
        data["alignment"] = this.alignment;
        data["allowEditing"] = this.allowEditing;
        data["allowFiltering"] = this.allowFiltering;
        data["allowFixing"] = this.allowFixing;
        data["allowGrouping"] = this.allowGrouping;
        data["allowHeaderFiltering"] = this.allowHeaderFiltering;
        data["allowHiding"] = this.allowHiding;
        data["allowSearch"] = this.allowSearch;
        data["allowSorting"] = this.allowSorting;
        data["autoExpandGroup"] = this.autoExpandGroup;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["column_child"] = this.column_child;
        data["cssClass"] = this.cssClass;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["companyCode"] = this.companyCode;
        data["orderNo"] = this.orderNo;
        return data;
    }
}

export interface ISysGenRowTable {
    id?: string | undefined;
    table_name?: string | undefined;
    dataField?: string | undefined;
    caption?: string | undefined;
    caption_VN?: string | undefined;
    name?: string | undefined;
    dataType?: string | undefined;
    format?: string | undefined;
    width?: number | undefined;
    visible?: boolean | undefined;
    minWidth?: number | undefined;
    alignment?: string | undefined;
    allowEditing?: boolean | undefined;
    allowFiltering?: boolean | undefined;
    allowFixing?: boolean | undefined;
    allowGrouping?: boolean | undefined;
    allowHeaderFiltering?: boolean | undefined;
    allowHiding?: boolean | undefined;
    allowSearch?: boolean | undefined;
    allowSorting?: boolean | undefined;
    autoExpandGroup?: boolean | undefined;
    columns?: SysGenRowTable[] | undefined;
    column_child?: string | undefined;
    cssClass?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    orderNo?: number | undefined;
}

export class StatusMessageOfListOfSysGenRowTable implements IStatusMessageOfListOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysGenRowTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysGenRowTable.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysGenRowTable {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysGenRowTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysGenRowTable {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysGenRowTable[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysVoucherFormColumn implements IStatusMessageOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysVoucherFormColumn.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn | undefined;
    currentID?: string | undefined;
}

export class SysVoucherFormColumn implements ISysVoucherFormColumn {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    labelModel?: string | undefined;
    edit?: boolean | undefined;
    labelControl?: string | undefined;
    labelRequired?: boolean | undefined;
    visible?: boolean | undefined;
    disabled?: boolean | undefined;
    readOnly?: boolean | undefined;
    required?: boolean | undefined;
    showClearButton?: boolean | undefined;
    label?: string | undefined;
    placeholder?: string | undefined;
    mode?: string | undefined;
    mask?: string | undefined;
    maskRules?: string | undefined;
    groupId?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    createBy?: string | undefined;
    typeControl?: string | undefined;
    format?: string | undefined;

    constructor(data?: ISysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.code = _data["code"];
            this.labelModel = _data["labelModel"];
            this.edit = _data["edit"];
            this.labelControl = _data["labelControl"];
            this.labelRequired = _data["labelRequired"];
            this.visible = _data["visible"];
            this.disabled = _data["disabled"];
            this.readOnly = _data["readOnly"];
            this.required = _data["required"];
            this.showClearButton = _data["showClearButton"];
            this.label = _data["label"];
            this.placeholder = _data["placeholder"];
            this.mode = _data["mode"];
            this.mask = _data["mask"];
            this.maskRules = _data["maskRules"];
            this.groupId = _data["groupId"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.companyCode = _data["companyCode"];
            this.createBy = _data["createBy"];
            this.typeControl = _data["typeControl"];
            this.format = _data["format"];
        }
    }

    static fromJS(data: any): SysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new SysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["code"] = this.code;
        data["labelModel"] = this.labelModel;
        data["edit"] = this.edit;
        data["labelControl"] = this.labelControl;
        data["labelRequired"] = this.labelRequired;
        data["visible"] = this.visible;
        data["disabled"] = this.disabled;
        data["readOnly"] = this.readOnly;
        data["required"] = this.required;
        data["showClearButton"] = this.showClearButton;
        data["label"] = this.label;
        data["placeholder"] = this.placeholder;
        data["mode"] = this.mode;
        data["mask"] = this.mask;
        data["maskRules"] = this.maskRules;
        data["groupId"] = this.groupId;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["companyCode"] = this.companyCode;
        data["createBy"] = this.createBy;
        data["typeControl"] = this.typeControl;
        data["format"] = this.format;
        return data;
    }
}

export interface ISysVoucherFormColumn {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    labelModel?: string | undefined;
    edit?: boolean | undefined;
    labelControl?: string | undefined;
    labelRequired?: boolean | undefined;
    visible?: boolean | undefined;
    disabled?: boolean | undefined;
    readOnly?: boolean | undefined;
    required?: boolean | undefined;
    showClearButton?: boolean | undefined;
    label?: string | undefined;
    placeholder?: string | undefined;
    mode?: string | undefined;
    mask?: string | undefined;
    maskRules?: string | undefined;
    groupId?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
    createBy?: string | undefined;
    typeControl?: string | undefined;
    format?: string | undefined;
}

export class StatusMessageOfListOfSysVoucherFormColumn implements IStatusMessageOfListOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysVoucherFormColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysVoucherFormColumn.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysVoucherFormColumn {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysVoucherFormColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysVoucherFormColumn {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormColumn[] | undefined;
    currentID?: string | undefined;
}

export class StatusMessageOfSysVoucherFormGroup implements IStatusMessageOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfSysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"] ? SysVoucherFormGroup.fromJS(_data["data"]) : <any>undefined;
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfSysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfSysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup | undefined;
    currentID?: string | undefined;
}

export class SysVoucherFormGroup implements ISysVoucherFormGroup {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    number_order?: number | undefined;
    group_id?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;

    constructor(data?: ISysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.table_name = _data["table_name"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.number_order = _data["number_order"];
            this.group_id = _data["group_id"];
            this.create_date = _data["create_date"] ? new Date(_data["create_date"].toString()) : <any>undefined;
            this.update_date = _data["update_date"] ? new Date(_data["update_date"].toString()) : <any>undefined;
            this.companyCode = _data["companyCode"];
        }
    }

    static fromJS(data: any): SysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["table_name"] = this.table_name;
        data["code"] = this.code;
        data["name"] = this.name;
        data["number_order"] = this.number_order;
        data["group_id"] = this.group_id;
        data["create_date"] = this.create_date ? this.create_date.toISOString() : <any>undefined;
        data["update_date"] = this.update_date ? this.update_date.toISOString() : <any>undefined;
        data["companyCode"] = this.companyCode;
        return data;
    }
}

export interface ISysVoucherFormGroup {
    id?: string | undefined;
    table_name?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    number_order?: number | undefined;
    group_id?: string | undefined;
    create_date?: Date | undefined;
    update_date?: Date | undefined;
    companyCode?: string | undefined;
}

export class StatusMessageOfListOfSysVoucherFormGroup implements IStatusMessageOfListOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup[] | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessageOfListOfSysVoucherFormGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SysVoucherFormGroup.fromJS(item));
            }
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessageOfListOfSysVoucherFormGroup {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessageOfListOfSysVoucherFormGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentID"] = this.currentID;
        return data;
    }
}

export interface IStatusMessageOfListOfSysVoucherFormGroup {
    status?: number | undefined;
    msg?: string | undefined;
    data?: SysVoucherFormGroup[] | undefined;
    currentID?: string | undefined;
}

export class CurrentJobPosition implements ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;

    constructor(data?: ICurrentJobPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.jobDescription = _data["jobDescription"];
            this.departmentOrTeam = _data["departmentOrTeam"];
            this.positionAndLevel = _data["positionAndLevel"];
            this.workSchedule = _data["workSchedule"];
            this.currentProjects = _data["currentProjects"];
            this.goalsAndDevelopment = _data["goalsAndDevelopment"];
        }
    }

    static fromJS(data: any): CurrentJobPosition {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentJobPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["jobDescription"] = this.jobDescription;
        data["departmentOrTeam"] = this.departmentOrTeam;
        data["positionAndLevel"] = this.positionAndLevel;
        data["workSchedule"] = this.workSchedule;
        data["currentProjects"] = this.currentProjects;
        data["goalsAndDevelopment"] = this.goalsAndDevelopment;
        return data;
    }
}

export interface ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;
}

export class SalaryAndBenefits implements ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;

    constructor(data?: ISalaryAndBenefits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.salary = _data["salary"];
            this.benefits = _data["benefits"];
            this.wagesAndPerks = _data["wagesAndPerks"];
            this.compensationPackageAmount = _data["compensationPackageAmount"];
            this.compensationPackage = _data["compensationPackage"];
            this.compensationPackageAmount1 = _data["compensationPackageAmount1"];
            this.compensationPackage1 = _data["compensationPackage1"];
            this.compensationPackageAmount2 = _data["compensationPackageAmount2"];
            this.compensationPackage2 = _data["compensationPackage2"];
            this.compensationPackageAmount3 = _data["compensationPackageAmount3"];
            this.compensationPackage3 = _data["compensationPackage3"];
            this.insuranceCoverage = _data["insuranceCoverage"];
            this.allowancesAndAidsAmount = _data["allowancesAndAidsAmount"];
            this.allowancesAndAids = _data["allowancesAndAids"];
            this.allowancesAndAidsAmount1 = _data["allowancesAndAidsAmount1"];
            this.allowancesAndAids1 = _data["allowancesAndAids1"];
            this.allowancesAndAidsAmount2 = _data["allowancesAndAidsAmount2"];
            this.allowancesAndAids2 = _data["allowancesAndAids2"];
            this.allowancesAndAidsAmount3 = _data["allowancesAndAidsAmount3"];
            this.allowancesAndAids3 = _data["allowancesAndAids3"];
        }
    }

    static fromJS(data: any): SalaryAndBenefits {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryAndBenefits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["salary"] = this.salary;
        data["benefits"] = this.benefits;
        data["wagesAndPerks"] = this.wagesAndPerks;
        data["compensationPackageAmount"] = this.compensationPackageAmount;
        data["compensationPackage"] = this.compensationPackage;
        data["compensationPackageAmount1"] = this.compensationPackageAmount1;
        data["compensationPackage1"] = this.compensationPackage1;
        data["compensationPackageAmount2"] = this.compensationPackageAmount2;
        data["compensationPackage2"] = this.compensationPackage2;
        data["compensationPackageAmount3"] = this.compensationPackageAmount3;
        data["compensationPackage3"] = this.compensationPackage3;
        data["insuranceCoverage"] = this.insuranceCoverage;
        data["allowancesAndAidsAmount"] = this.allowancesAndAidsAmount;
        data["allowancesAndAids"] = this.allowancesAndAids;
        data["allowancesAndAidsAmount1"] = this.allowancesAndAidsAmount1;
        data["allowancesAndAids1"] = this.allowancesAndAids1;
        data["allowancesAndAidsAmount2"] = this.allowancesAndAidsAmount2;
        data["allowancesAndAids2"] = this.allowancesAndAids2;
        data["allowancesAndAidsAmount3"] = this.allowancesAndAidsAmount3;
        data["allowancesAndAids3"] = this.allowancesAndAids3;
        return data;
    }
}

export interface ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;
}

export class WorkHistory implements IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;

    constructor(data?: IWorkHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.companyAndPosition = _data["companyAndPosition"];
            this.workHistoryStart = _data["workHistoryStart"] ? new Date(_data["workHistoryStart"].toString()) : <any>undefined;
            this.workHistoryEnd = _data["workHistoryEnd"] ? new Date(_data["workHistoryEnd"].toString()) : <any>undefined;
            this.timeWorked = _data["timeWorked"];
            this.jobdeScription = _data["jobdeScription"];
            this.achievementSkills = _data["achievementSkills"];
            this.reasonForChange = _data["reasonForChange"];
        }
    }

    static fromJS(data: any): WorkHistory {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["companyAndPosition"] = this.companyAndPosition;
        data["workHistoryStart"] = this.workHistoryStart ? this.workHistoryStart.toISOString() : <any>undefined;
        data["workHistoryEnd"] = this.workHistoryEnd ? this.workHistoryEnd.toISOString() : <any>undefined;
        data["timeWorked"] = this.timeWorked;
        data["jobdeScription"] = this.jobdeScription;
        data["achievementSkills"] = this.achievementSkills;
        data["reasonForChange"] = this.reasonForChange;
        return data;
    }
}

export interface IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;
}

export class AccountClientLoginParamsModel implements IAccountClientLoginParamsModel {
    account?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;

    constructor(data?: IAccountClientLoginParamsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.companyCode = _data["companyCode"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.ip_address = _data["ip_address"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): AccountClientLoginParamsModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientLoginParamsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["companyCode"] = this.companyCode;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["ip_address"] = this.ip_address;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IAccountClientLoginParamsModel {
    account?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
}

export class AccountClientProfileModel implements IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;

    constructor(data?: IAccountClientProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            this.userInfo = _data["userInfo"] ? UserInfo.fromJS(_data["userInfo"]) : <any>undefined;
            this.token = _data["token"] ? TOKEN.fromJS(_data["token"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountClientProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["userInfo"] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
        data["token"] = this.token ? this.token.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;
}

export class Account implements IAccount {
    account?: string | undefined;
    password?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;
    language?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.status = _data["status"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.type_account = _data["type_account"];
            this.token = _data["token"];
            this.codePermision = _data["codePermision"];
            this.companyCode = _data["companyCode"];
            this.namePermision = _data["namePermision"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["status"] = this.status;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["type_account"] = this.type_account;
        data["token"] = this.token;
        data["codePermision"] = this.codePermision;
        data["companyCode"] = this.companyCode;
        data["namePermision"] = this.namePermision;
        data["language"] = this.language;
        return data;
    }
}

export interface IAccount {
    account?: string | undefined;
    password?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;
    language?: string | undefined;
}

export class UserInfo implements IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        return data;
    }
}

export interface IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
}

export class TOKEN implements ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;

    constructor(data?: ITOKEN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.username = _data["username"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.last_date_connect = _data["last_date_connect"] ? new Date(_data["last_date_connect"].toString()) : <any>undefined;
            this.is_connecting = _data["is_connecting"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ip_address = _data["ip_address"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.connectionSignalID = _data["connectionSignalID"];
        }
    }

    static fromJS(data: any): TOKEN {
        data = typeof data === 'object' ? data : {};
        let result = new TOKEN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["username"] = this.username;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["last_date_connect"] = this.last_date_connect ? this.last_date_connect.toISOString() : <any>undefined;
        data["is_connecting"] = this.is_connecting;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ip_address"] = this.ip_address;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["connectionSignalID"] = this.connectionSignalID;
        return data;
    }
}

export interface ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;
}

export class SysMenu implements ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    nameVN?: string | undefined;
    icon?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;
    action1?: string | undefined;
    action2?: string | undefined;
    action3?: string | undefined;
    action4?: string | undefined;
    action5?: string | undefined;
    action6?: string | undefined;
    action7?: string | undefined;

    constructor(data?: ISysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuid = _data["menuid"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.nameVN = _data["nameVN"];
            this.icon = _data["icon"];
            this.active = _data["active"];
            this.isParent = _data["isParent"];
            this.menuIDParent = _data["menuIDParent"];
            this.defaultActive = _data["defaultActive"];
            this.moduleApp = _data["moduleApp"];
            this.action1 = _data["action1"];
            this.action2 = _data["action2"];
            this.action3 = _data["action3"];
            this.action4 = _data["action4"];
            this.action5 = _data["action5"];
            this.action6 = _data["action6"];
            this.action7 = _data["action7"];
        }
    }

    static fromJS(data: any): SysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new SysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuid"] = this.menuid;
        data["url"] = this.url;
        data["name"] = this.name;
        data["nameVN"] = this.nameVN;
        data["icon"] = this.icon;
        data["active"] = this.active;
        data["isParent"] = this.isParent;
        data["menuIDParent"] = this.menuIDParent;
        data["defaultActive"] = this.defaultActive;
        data["moduleApp"] = this.moduleApp;
        data["action1"] = this.action1;
        data["action2"] = this.action2;
        data["action3"] = this.action3;
        data["action4"] = this.action4;
        data["action5"] = this.action5;
        data["action6"] = this.action6;
        data["action7"] = this.action7;
        return data;
    }
}

export interface ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    nameVN?: string | undefined;
    icon?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;
    action1?: string | undefined;
    action2?: string | undefined;
    action3?: string | undefined;
    action4?: string | undefined;
    action5?: string | undefined;
    action6?: string | undefined;
    action7?: string | undefined;
}

export class Sys_Menu_Tree_View_MODEL extends SysMenu implements ISys_Menu_Tree_View_MODEL {
    items?: Sys_Menu_Tree_View_MODEL[] | undefined;
    expanded?: boolean | undefined;
    selected?: boolean | undefined;
    account?: string | undefined;

    constructor(data?: ISys_Menu_Tree_View_MODEL) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Sys_Menu_Tree_View_MODEL.fromJS(item));
            }
            this.expanded = _data["expanded"];
            this.selected = _data["selected"];
            this.account = _data["account"];
        }
    }

    static override fromJS(data: any): Sys_Menu_Tree_View_MODEL {
        data = typeof data === 'object' ? data : {};
        let result = new Sys_Menu_Tree_View_MODEL();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["expanded"] = this.expanded;
        data["selected"] = this.selected;
        data["account"] = this.account;
        super.toJSON(data);
        return data;
    }
}

export interface ISys_Menu_Tree_View_MODEL extends ISysMenu {
    items?: Sys_Menu_Tree_View_MODEL[] | undefined;
    expanded?: boolean | undefined;
    selected?: boolean | undefined;
    account?: string | undefined;
}

export class UserInformationClientGetUser implements IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[] | undefined;

    constructor(data?: IUserInformationClientGetUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
            this.nameCompany = _data["nameCompany"];
            this.email = _data["email"];
            this.nameDepartment = _data["nameDepartment"];
            this.nameBrach = _data["nameBrach"];
            this.codeDepartment = _data["codeDepartment"];
            this.codeName = _data["codeName"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(TOKEN.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInformationClientGetUser {
        data = typeof data === 'object' ? data : {};
        let result = new UserInformationClientGetUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        data["nameCompany"] = this.nameCompany;
        data["email"] = this.email;
        data["nameDepartment"] = this.nameDepartment;
        data["nameBrach"] = this.nameBrach;
        data["codeDepartment"] = this.codeDepartment;
        data["codeName"] = this.codeName;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[] | undefined;
}

export class Company implements ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.adminCompany = _data["adminCompany"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["adminCompany"] = this.adminCompany;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;
}

export class SysStatus implements ISysStatus {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    accept_login?: boolean | undefined;

    constructor(data?: ISysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.accept_login = _data["accept_login"];
        }
    }

    static fromJS(data: any): SysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["accept_login"] = this.accept_login;
        return data;
    }
}

export interface ISysStatus {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    accept_login?: boolean | undefined;
}

export class SysPermission implements ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: string | undefined;
    codeCompany?: string | undefined;

    constructor(data?: ISysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.order_number = _data["order_number"];
            this.codeCompany = _data["codeCompany"];
        }
    }

    static fromJS(data: any): SysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new SysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["order_number"] = this.order_number;
        data["codeCompany"] = this.codeCompany;
        return data;
    }
}

export interface ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: string | undefined;
    codeCompany?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}