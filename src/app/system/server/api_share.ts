//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import LayoutComponentBase from 'src/app/share/layoutBase/LayoutComponentBase';
import { Injector } from '@angular/core';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { APIBase } from './APIBase';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICurrentJobPositionsClient {
    getCurrentJobPositions(): Observable<CurrentJobPosition[]>;
    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition>;
    getCurrentJobPosition(id: string): Observable<CurrentJobPosition>;
    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse>;
    deleteCurrentJobPosition(id: string): Observable<FileResponse>;
}

@Injectable()
export class CurrentJobPositionsClient extends APIBase implements ICurrentJobPositionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getCurrentJobPositions(): Observable<CurrentJobPosition[]> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition[]>;
        }));
    }

    protected processGetCurrentJobPositions(response: HttpResponseBase): Observable<CurrentJobPosition[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrentJobPosition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postCurrentJobPosition(currentJobPosition: CurrentJobPosition): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processPostCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrentJobPosition(id: string): Observable<CurrentJobPosition> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentJobPosition>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentJobPosition>;
        }));
    }

    protected processGetCurrentJobPosition(response: HttpResponseBase): Observable<CurrentJobPosition> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentJobPosition.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putCurrentJobPosition(id: string, currentJobPosition: CurrentJobPosition): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(currentJobPosition);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCurrentJobPosition(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CurrentJobPositions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCurrentJobPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCurrentJobPosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCurrentJobPosition(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISalaryAndBenefitsClient {
    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]>;
    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits>;
    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits>;
    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse>;
    deleteSalaryAndBenefits(id: string): Observable<FileResponse>;
}

@Injectable()
export class SalaryAndBenefitsClient extends APIBase implements ISalaryAndBenefitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getSalaryAndBenefitsAll(): Observable<SalaryAndBenefits[]> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefitsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefitsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits[]>;
        }));
    }

    protected processGetSalaryAndBenefitsAll(response: HttpResponseBase): Observable<SalaryAndBenefits[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalaryAndBenefits.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postSalaryAndBenefits(salaryAndBenefits: SalaryAndBenefits): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processPostSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSalaryAndBenefits(id: string): Observable<SalaryAndBenefits> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalaryAndBenefits>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalaryAndBenefits>;
        }));
    }

    protected processGetSalaryAndBenefits(response: HttpResponseBase): Observable<SalaryAndBenefits> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalaryAndBenefits.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putSalaryAndBenefits(id: string, salaryAndBenefits: SalaryAndBenefits): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salaryAndBenefits);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSalaryAndBenefits(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SalaryAndBenefits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteSalaryAndBenefits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSalaryAndBenefits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteSalaryAndBenefits(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWorkHistoriesClient {
    getWorkHistories(): Observable<WorkHistory[]>;
    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory>;
    getWorkHistory(id: string): Observable<WorkHistory>;
    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse>;
    deleteWorkHistory(id: string): Observable<FileResponse>;
}

@Injectable()
export class WorkHistoriesClient extends APIBase implements IWorkHistoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getWorkHistories(): Observable<WorkHistory[]> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory[]>;
        }));
    }

    protected processGetWorkHistories(response: HttpResponseBase): Observable<WorkHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postWorkHistory(workHistory: WorkHistory): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPostWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processPostWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWorkHistory(id: string): Observable<WorkHistory> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkHistory>;
        }));
    }

    protected processGetWorkHistory(response: HttpResponseBase): Observable<WorkHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putWorkHistory(id: string, workHistory: WorkHistory): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workHistory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteWorkHistory(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkHistories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWorkHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteWorkHistory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAccountsClient {
    checkTheExpirationDateOfToken(): Observable<boolean>;
    login(account: AccountClientLoginParamsModel): Observable<StatusMessage>;
    accountIns(profile: AccountClientProfileModel): Observable<StatusMessage>;
    updateAccount(account: Account): Observable<StatusMessage>;
    deleteAccount(id: string): Observable<StatusMessage>;
}

@Injectable()
export class AccountsClient extends APIBase implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    checkTheExpirationDateOfToken(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Accounts/CheckTheExpirationDateOfToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckTheExpirationDateOfToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTheExpirationDateOfToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckTheExpirationDateOfToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(account: AccountClientLoginParamsModel): Observable<StatusMessage> {
        let url_ = this.baseUrl + "/api/Accounts/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessage>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<StatusMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accountIns(profile: AccountClientProfileModel): Observable<StatusMessage> {
        let url_ = this.baseUrl + "/api/Accounts/AccountIns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAccountIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessage>;
        }));
    }

    protected processAccountIns(response: HttpResponseBase): Observable<StatusMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAccount(account: Account): Observable<StatusMessage> {
        let url_ = this.baseUrl + "/api/Accounts/UpdateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessage>;
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<StatusMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAccount(id: string): Observable<StatusMessage> {
        let url_ = this.baseUrl + "/api/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessage>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<StatusMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMenuPermissionsClient {
    getListMenu(): Observable<SysMenu[]>;
    getAllListMenus(): Observable<SysMenu>;
}

@Injectable()
export class MenuPermissionsClient extends APIBase implements IMenuPermissionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    getListMenu(): Observable<SysMenu[]> {
        let url_ = this.baseUrl + "/api/MenuPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu[]>;
        }));
    }

    protected processGetListMenu(response: HttpResponseBase): Observable<SysMenu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysMenu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllListMenus(): Observable<SysMenu> {
        let url_ = this.baseUrl + "/api/MenuPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllListMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllListMenus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysMenu>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysMenu>;
        }));
    }

    protected processGetAllListMenus(response: HttpResponseBase): Observable<SysMenu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SysMenu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserInfoesClient {
    userIns(userInfo: UserInfo): Observable<StatusMessage>;
    updUser(userInfo: UserInfo): Observable<StatusMessage>;
    getMyUser(): Observable<UserInfo>;
    getLstUser(): Observable<UserInfo[]>;
    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser>;
    deleteUserInfo(id: string): Observable<FileResponse>;
}

@Injectable()
export class UserInfoesClient extends APIBase implements IUserInfoesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    userIns(userInfo: UserInfo): Observable<StatusMessage> {
        let url_ = this.baseUrl + "/api/UserInfoes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUserIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessage>;
        }));
    }

    protected processUserIns(response: HttpResponseBase): Observable<StatusMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updUser(userInfo: UserInfo): Observable<StatusMessage> {
        let url_ = this.baseUrl + "/api/UserInfoes/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusMessage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusMessage>;
        }));
    }

    protected processUpdUser(response: HttpResponseBase): Observable<StatusMessage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyUser(): Observable<UserInfo> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMyUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo>;
        }));
    }

    protected processGetMyUser(response: HttpResponseBase): Observable<UserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLstUser(): Observable<UserInfo[]> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLstUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLstUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo[]>;
        }));
    }

    protected processGetLstUser(response: HttpResponseBase): Observable<UserInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserInformation(username?: string | null | undefined): Observable<UserInformationClientGetUser> {
        let url_ = this.baseUrl + "/api/UserInfoes/GetUserInformation?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserInformation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInformation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInformationClientGetUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInformationClientGetUser>;
        }));
    }

    protected processGetUserInformation(response: HttpResponseBase): Observable<UserInformationClientGetUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInformationClientGetUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUserInfo(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserInfoes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteUserInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICommonContronllerClient {
    listCompany(): Observable<Company[]>;
    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]>;
    getPermissionByCompany(): Observable<SysPermission[]>;
}

@Injectable()
export class CommonContronllerClient extends APIBase implements ICommonContronllerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Injector) configuration: Injector, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ?? this.getBaseUrl("");
    }

    listCompany(): Observable<Company[]> {
        let url_ = this.baseUrl + "/api/CommonContronller";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processListCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Company[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Company[]>;
        }));
    }

    protected processListCompany(response: HttpResponseBase): Observable<Company[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Company.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStatusByModule(pSysStatus: SysStatus): Observable<SysStatus[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListStatusByModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pSysStatus);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatusByModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusByModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysStatus[]>;
        }));
    }

    protected processGetStatusByModule(response: HttpResponseBase): Observable<SysStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPermissionByCompany(): Observable<SysPermission[]> {
        let url_ = this.baseUrl + "/api/CommonContronller/ListPermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionByCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionByCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SysPermission[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SysPermission[]>;
        }));
    }

    protected processGetPermissionByCompany(response: HttpResponseBase): Observable<SysPermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SysPermission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CurrentJobPosition implements ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;

    constructor(data?: ICurrentJobPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.jobDescription = _data["jobDescription"];
            this.departmentOrTeam = _data["departmentOrTeam"];
            this.positionAndLevel = _data["positionAndLevel"];
            this.workSchedule = _data["workSchedule"];
            this.currentProjects = _data["currentProjects"];
            this.goalsAndDevelopment = _data["goalsAndDevelopment"];
        }
    }

    static fromJS(data: any): CurrentJobPosition {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentJobPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["jobDescription"] = this.jobDescription;
        data["departmentOrTeam"] = this.departmentOrTeam;
        data["positionAndLevel"] = this.positionAndLevel;
        data["workSchedule"] = this.workSchedule;
        data["currentProjects"] = this.currentProjects;
        data["goalsAndDevelopment"] = this.goalsAndDevelopment;
        return data;
    }

    clone(): CurrentJobPosition {
        const json = this.toJSON();
        let result = new CurrentJobPosition();
        result.init(json);
        return result;
    }
}

export interface ICurrentJobPosition {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    jobDescription?: string | undefined;
    departmentOrTeam?: string | undefined;
    positionAndLevel?: string | undefined;
    workSchedule?: string | undefined;
    currentProjects?: string | undefined;
    goalsAndDevelopment?: string | undefined;
}

export class SalaryAndBenefits implements ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;

    constructor(data?: ISalaryAndBenefits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.salary = _data["salary"];
            this.benefits = _data["benefits"];
            this.wagesAndPerks = _data["wagesAndPerks"];
            this.compensationPackageAmount = _data["compensationPackageAmount"];
            this.compensationPackage = _data["compensationPackage"];
            this.compensationPackageAmount1 = _data["compensationPackageAmount1"];
            this.compensationPackage1 = _data["compensationPackage1"];
            this.compensationPackageAmount2 = _data["compensationPackageAmount2"];
            this.compensationPackage2 = _data["compensationPackage2"];
            this.compensationPackageAmount3 = _data["compensationPackageAmount3"];
            this.compensationPackage3 = _data["compensationPackage3"];
            this.insuranceCoverage = _data["insuranceCoverage"];
            this.allowancesAndAidsAmount = _data["allowancesAndAidsAmount"];
            this.allowancesAndAids = _data["allowancesAndAids"];
            this.allowancesAndAidsAmount1 = _data["allowancesAndAidsAmount1"];
            this.allowancesAndAids1 = _data["allowancesAndAids1"];
            this.allowancesAndAidsAmount2 = _data["allowancesAndAidsAmount2"];
            this.allowancesAndAids2 = _data["allowancesAndAids2"];
            this.allowancesAndAidsAmount3 = _data["allowancesAndAidsAmount3"];
            this.allowancesAndAids3 = _data["allowancesAndAids3"];
        }
    }

    static fromJS(data: any): SalaryAndBenefits {
        data = typeof data === 'object' ? data : {};
        let result = new SalaryAndBenefits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["salary"] = this.salary;
        data["benefits"] = this.benefits;
        data["wagesAndPerks"] = this.wagesAndPerks;
        data["compensationPackageAmount"] = this.compensationPackageAmount;
        data["compensationPackage"] = this.compensationPackage;
        data["compensationPackageAmount1"] = this.compensationPackageAmount1;
        data["compensationPackage1"] = this.compensationPackage1;
        data["compensationPackageAmount2"] = this.compensationPackageAmount2;
        data["compensationPackage2"] = this.compensationPackage2;
        data["compensationPackageAmount3"] = this.compensationPackageAmount3;
        data["compensationPackage3"] = this.compensationPackage3;
        data["insuranceCoverage"] = this.insuranceCoverage;
        data["allowancesAndAidsAmount"] = this.allowancesAndAidsAmount;
        data["allowancesAndAids"] = this.allowancesAndAids;
        data["allowancesAndAidsAmount1"] = this.allowancesAndAidsAmount1;
        data["allowancesAndAids1"] = this.allowancesAndAids1;
        data["allowancesAndAidsAmount2"] = this.allowancesAndAidsAmount2;
        data["allowancesAndAids2"] = this.allowancesAndAids2;
        data["allowancesAndAidsAmount3"] = this.allowancesAndAidsAmount3;
        data["allowancesAndAids3"] = this.allowancesAndAids3;
        return data;
    }

    clone(): SalaryAndBenefits {
        const json = this.toJSON();
        let result = new SalaryAndBenefits();
        result.init(json);
        return result;
    }
}

export interface ISalaryAndBenefits {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    salary?: number | undefined;
    benefits?: string | undefined;
    wagesAndPerks?: string | undefined;
    compensationPackageAmount?: number | undefined;
    compensationPackage?: string | undefined;
    compensationPackageAmount1?: number | undefined;
    compensationPackage1?: string | undefined;
    compensationPackageAmount2?: number | undefined;
    compensationPackage2?: string | undefined;
    compensationPackageAmount3?: number | undefined;
    compensationPackage3?: string | undefined;
    insuranceCoverage?: string | undefined;
    allowancesAndAidsAmount?: number | undefined;
    allowancesAndAids?: string | undefined;
    allowancesAndAidsAmount1?: number | undefined;
    allowancesAndAids1?: string | undefined;
    allowancesAndAidsAmount2?: number | undefined;
    allowancesAndAids2?: string | undefined;
    allowancesAndAidsAmount3?: number | undefined;
    allowancesAndAids3?: string | undefined;
}

export class WorkHistory implements IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;

    constructor(data?: IWorkHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.idUserInfo = _data["idUserInfo"];
            this.modyfiBy = _data["modyfiBy"];
            this.companyAndPosition = _data["companyAndPosition"];
            this.workHistoryStart = _data["workHistoryStart"] ? new Date(_data["workHistoryStart"].toString()) : <any>undefined;
            this.workHistoryEnd = _data["workHistoryEnd"] ? new Date(_data["workHistoryEnd"].toString()) : <any>undefined;
            this.timeWorked = _data["timeWorked"];
            this.jobdeScription = _data["jobdeScription"];
            this.achievementSkills = _data["achievementSkills"];
            this.reasonForChange = _data["reasonForChange"];
        }
    }

    static fromJS(data: any): WorkHistory {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["idUserInfo"] = this.idUserInfo;
        data["modyfiBy"] = this.modyfiBy;
        data["companyAndPosition"] = this.companyAndPosition;
        data["workHistoryStart"] = this.workHistoryStart ? this.workHistoryStart.toISOString() : <any>undefined;
        data["workHistoryEnd"] = this.workHistoryEnd ? this.workHistoryEnd.toISOString() : <any>undefined;
        data["timeWorked"] = this.timeWorked;
        data["jobdeScription"] = this.jobdeScription;
        data["achievementSkills"] = this.achievementSkills;
        data["reasonForChange"] = this.reasonForChange;
        return data;
    }

    clone(): WorkHistory {
        const json = this.toJSON();
        let result = new WorkHistory();
        result.init(json);
        return result;
    }
}

export interface IWorkHistory {
    id?: string | undefined;
    date?: Date | undefined;
    idUserInfo?: string | undefined;
    modyfiBy?: string | undefined;
    companyAndPosition?: string | undefined;
    workHistoryStart?: Date | undefined;
    workHistoryEnd?: Date | undefined;
    timeWorked?: string | undefined;
    jobdeScription?: string | undefined;
    achievementSkills?: string | undefined;
    reasonForChange?: string | undefined;
}

export class StatusMessage implements IStatusMessage {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;

    constructor(data?: IStatusMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.msg = _data["msg"];
            this.data = _data["data"];
            this.currentID = _data["currentID"];
        }
    }

    static fromJS(data: any): StatusMessage {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["data"] = this.data;
        data["currentID"] = this.currentID;
        return data;
    }

    clone(): StatusMessage {
        const json = this.toJSON();
        let result = new StatusMessage();
        result.init(json);
        return result;
    }
}

export interface IStatusMessage {
    status?: number | undefined;
    msg?: string | undefined;
    data?: any | undefined;
    currentID?: string | undefined;
}

export class AccountClientLoginParamsModel implements IAccountClientLoginParamsModel {
    account?: string;
    password?: string;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;

    constructor(data?: IAccountClientLoginParamsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.companyCode = _data["companyCode"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.ip_address = _data["ip_address"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): AccountClientLoginParamsModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientLoginParamsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["companyCode"] = this.companyCode;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["ip_address"] = this.ip_address;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): AccountClientLoginParamsModel {
        const json = this.toJSON();
        let result = new AccountClientLoginParamsModel();
        result.init(json);
        return result;
    }
}

export interface IAccountClientLoginParamsModel {
    account?: string;
    password?: string;
    email?: string | undefined;
    phone?: string | undefined;
    companyCode?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    ip_address?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
}

export class AccountClientProfileModel implements IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;

    constructor(data?: IAccountClientProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
            this.userInfo = _data["userInfo"] ? UserInfo.fromJS(_data["userInfo"]) : <any>undefined;
            this.token = _data["token"] ? TOKEN.fromJS(_data["token"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountClientProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClientProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["userInfo"] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
        data["token"] = this.token ? this.token.toJSON() : <any>undefined;
        return data;
    }

    clone(): AccountClientProfileModel {
        const json = this.toJSON();
        let result = new AccountClientProfileModel();
        result.init(json);
        return result;
    }
}

export interface IAccountClientProfileModel {
    account?: Account | undefined;
    userInfo?: UserInfo | undefined;
    token?: TOKEN | undefined;
}

export class Account implements IAccount {
    account?: string | undefined;
    password?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.status = _data["status"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.type_account = _data["type_account"];
            this.token = _data["token"];
            this.codePermision = _data["codePermision"];
            this.companyCode = _data["companyCode"];
            this.namePermision = _data["namePermision"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["status"] = this.status;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["type_account"] = this.type_account;
        data["token"] = this.token;
        data["codePermision"] = this.codePermision;
        data["companyCode"] = this.companyCode;
        data["namePermision"] = this.namePermision;
        return data;
    }

    clone(): Account {
        const json = this.toJSON();
        let result = new Account();
        result.init(json);
        return result;
    }
}

export interface IAccount {
    account?: string | undefined;
    password?: string | undefined;
    status?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    type_account?: string | undefined;
    token?: string | undefined;
    codePermision?: string | undefined;
    companyCode?: string | undefined;
    namePermision?: string | undefined;
}

export class UserInfo implements IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        return data;
    }

    clone(): UserInfo {
        const json = this.toJSON();
        let result = new UserInfo();
        result.init(json);
        return result;
    }
}

export interface IUserInfo {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
}

export class TOKEN implements ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;

    constructor(data?: ITOKEN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.username = _data["username"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.last_date_connect = _data["last_date_connect"] ? new Date(_data["last_date_connect"].toString()) : <any>undefined;
            this.is_connecting = _data["is_connecting"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.ip_address = _data["ip_address"];
            this.type_device = _data["type_device"];
            this.os = _data["os"];
            this.browser = _data["browser"];
            this.device = _data["device"];
            this.os_version = _data["os_version"];
            this.browser_version = _data["browser_version"];
            this.is_mobile = _data["is_mobile"];
            this.is_tablet = _data["is_tablet"];
            this.is_desktop = _data["is_desktop"];
            this.is_ios = _data["is_ios"];
            this.is_android = _data["is_android"];
            this.orientation = _data["orientation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.connectionSignalID = _data["connectionSignalID"];
        }
    }

    static fromJS(data: any): TOKEN {
        data = typeof data === 'object' ? data : {};
        let result = new TOKEN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["username"] = this.username;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["last_date_connect"] = this.last_date_connect ? this.last_date_connect.toISOString() : <any>undefined;
        data["is_connecting"] = this.is_connecting;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ip_address"] = this.ip_address;
        data["type_device"] = this.type_device;
        data["os"] = this.os;
        data["browser"] = this.browser;
        data["device"] = this.device;
        data["os_version"] = this.os_version;
        data["browser_version"] = this.browser_version;
        data["is_mobile"] = this.is_mobile;
        data["is_tablet"] = this.is_tablet;
        data["is_desktop"] = this.is_desktop;
        data["is_ios"] = this.is_ios;
        data["is_android"] = this.is_android;
        data["orientation"] = this.orientation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["connectionSignalID"] = this.connectionSignalID;
        return data;
    }

    clone(): TOKEN {
        const json = this.toJSON();
        let result = new TOKEN();
        result.init(json);
        return result;
    }
}

export interface ITOKEN {
    id?: string | undefined;
    token?: string | undefined;
    username?: string | undefined;
    date?: Date | undefined;
    last_date_connect?: Date | undefined;
    is_connecting?: boolean | undefined;
    endDate?: Date | undefined;
    ip_address?: string | undefined;
    type_device?: string | undefined;
    os?: string | undefined;
    browser?: string | undefined;
    device?: string | undefined;
    os_version?: string | undefined;
    browser_version?: string | undefined;
    is_mobile?: boolean | undefined;
    is_tablet?: boolean | undefined;
    is_desktop?: boolean | undefined;
    is_ios?: boolean | undefined;
    is_android?: boolean | undefined;
    orientation?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    connectionSignalID?: string | undefined;
}

export class SysMenu implements ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;

    constructor(data?: ISysMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuid = _data["menuid"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.active = _data["active"];
            this.isParent = _data["isParent"];
            this.menuIDParent = _data["menuIDParent"];
            this.defaultActive = _data["defaultActive"];
            this.moduleApp = _data["moduleApp"];
        }
    }

    static fromJS(data: any): SysMenu {
        data = typeof data === 'object' ? data : {};
        let result = new SysMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuid"] = this.menuid;
        data["url"] = this.url;
        data["name"] = this.name;
        data["active"] = this.active;
        data["isParent"] = this.isParent;
        data["menuIDParent"] = this.menuIDParent;
        data["defaultActive"] = this.defaultActive;
        data["moduleApp"] = this.moduleApp;
        return data;
    }

    clone(): SysMenu {
        const json = this.toJSON();
        let result = new SysMenu();
        result.init(json);
        return result;
    }
}

export interface ISysMenu {
    menuid?: string | undefined;
    url?: string | undefined;
    name?: string | undefined;
    active?: boolean | undefined;
    isParent?: boolean | undefined;
    menuIDParent?: string | undefined;
    defaultActive?: boolean | undefined;
    moduleApp?: string | undefined;
}

export class UserInformationClientGetUser implements IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[];

    constructor(data?: IUserInformationClientGetUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.ethnicity = _data["ethnicity"];
            this.interests = _data["interests"];
            this.maritalStatus = _data["maritalStatus"];
            this.modifyDate = _data["modifyDate"] ? new Date(_data["modifyDate"].toString()) : <any>undefined;
            this.bhxh = _data["bhxh"];
            this.cccd = _data["cccd"];
            this.codeCompany = _data["codeCompany"];
            this.avatar = _data["avatar"];
            this.avatar16 = _data["avatar16"];
            this.avatar32 = _data["avatar32"];
            this.avatar64 = _data["avatar64"];
            this.nameCompany = _data["nameCompany"];
            this.email = _data["email"];
            this.nameDepartment = _data["nameDepartment"];
            this.nameBrach = _data["nameBrach"];
            this.codeDepartment = _data["codeDepartment"];
            this.codeName = _data["codeName"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(TOKEN.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInformationClientGetUser {
        data = typeof data === 'object' ? data : {};
        let result = new UserInformationClientGetUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["ethnicity"] = this.ethnicity;
        data["interests"] = this.interests;
        data["maritalStatus"] = this.maritalStatus;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["bhxh"] = this.bhxh;
        data["cccd"] = this.cccd;
        data["codeCompany"] = this.codeCompany;
        data["avatar"] = this.avatar;
        data["avatar16"] = this.avatar16;
        data["avatar32"] = this.avatar32;
        data["avatar64"] = this.avatar64;
        data["nameCompany"] = this.nameCompany;
        data["email"] = this.email;
        data["nameDepartment"] = this.nameDepartment;
        data["nameBrach"] = this.nameBrach;
        data["codeDepartment"] = this.codeDepartment;
        data["codeName"] = this.codeName;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserInformationClientGetUser {
        const json = this.toJSON();
        let result = new UserInformationClientGetUser();
        result.init(json);
        return result;
    }
}

export interface IUserInformationClientGetUser {
    id?: string | undefined;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    gender?: string | undefined;
    nationality?: string | undefined;
    ethnicity?: string | undefined;
    interests?: string | undefined;
    maritalStatus?: string | undefined;
    modifyDate?: Date | undefined;
    bhxh?: string | undefined;
    cccd?: string | undefined;
    codeCompany?: string | undefined;
    avatar?: string | undefined;
    avatar16?: string | undefined;
    avatar32?: string | undefined;
    avatar64?: string | undefined;
    nameCompany?: string | undefined;
    email?: string | undefined;
    nameDepartment?: string | undefined;
    nameBrach?: string | undefined;
    codeDepartment?: string | undefined;
    codeName?: string | undefined;
    tokens?: TOKEN[];
}

export class Company implements ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.adminCompany = _data["adminCompany"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["adminCompany"] = this.adminCompany;
        data["notes"] = this.notes;
        return data;
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    date?: Date | undefined;
    adminCompany?: string | undefined;
    notes?: string | undefined;
}

export class SysStatus implements ISysStatus {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    accept_login?: boolean | undefined;

    constructor(data?: ISysStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.accept_login = _data["accept_login"];
        }
    }

    static fromJS(data: any): SysStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SysStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["accept_login"] = this.accept_login;
        return data;
    }

    clone(): SysStatus {
        const json = this.toJSON();
        let result = new SysStatus();
        result.init(json);
        return result;
    }
}

export interface ISysStatus {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    accept_login?: boolean | undefined;
}

export class SysPermission implements ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: string | undefined;
    codeCompany?: string | undefined;

    constructor(data?: ISysPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.order_number = _data["order_number"];
            this.codeCompany = _data["codeCompany"];
        }
    }

    static fromJS(data: any): SysPermission {
        data = typeof data === 'object' ? data : {};
        let result = new SysPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["order_number"] = this.order_number;
        data["codeCompany"] = this.codeCompany;
        return data;
    }

    clone(): SysPermission {
        const json = this.toJSON();
        let result = new SysPermission();
        result.init(json);
        return result;
    }
}

export interface ISysPermission {
    code?: string | undefined;
    name?: string | undefined;
    level?: number | undefined;
    order_number?: string | undefined;
    codeCompany?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}